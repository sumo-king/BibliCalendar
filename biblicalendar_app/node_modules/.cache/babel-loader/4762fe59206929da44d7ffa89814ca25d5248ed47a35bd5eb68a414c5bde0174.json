{"ast":null,"code":"/*! @hebcal/hdate v0.13.5, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport poAshkenazi from './ashkenazi.po.js';\nimport poHe from './he.po.js';\nconst noopLocale = {\n  headers: {\n    'plural-forms': 'nplurals=2; plural=(n!=1);'\n  },\n  contexts: {\n    '': {}\n  }\n};\nconst alias = {\n  h: 'he',\n  a: 'ashkenazi',\n  s: 'en',\n  '': 'en'\n};\n/** @private */\nconst locales = new Map();\n/** @private */\nlet activeLocale;\n/** @private */\nlet activeName;\n/** @private */\nfunction getEnOrdinal(n) {\n  const s = ['th', 'st', 'nd', 'rd'];\n  const v = n % 100;\n  return n + (s[(v - 20) % 10] || s[v] || s[0]);\n}\n/** @private */\nfunction checkLocale(locale) {\n  if (typeof locale !== 'string') {\n    throw new TypeError(`Invalid locale name: ${locale}`);\n  }\n  return locale.toLowerCase();\n}\n/** @private */\nfunction getExistingLocale(locale) {\n  const locale1 = checkLocale(locale);\n  const loc = locales.get(locale1);\n  if (!loc) {\n    throw new RangeError(`Locale '${locale}' not found`);\n  }\n  return loc;\n}\n/**\n * A locale in Hebcal is used for translations/transliterations of\n * holidays. `@hebcal/hdate` supports four locales by default\n * * `en` - default, Sephardic transliterations (e.g. \"Shabbat\")\n * * `ashkenazi` - Ashkenazi transliterations (e.g. \"Shabbos\")\n * * `he` - Hebrew (e.g. \"שַׁבָּת\")\n * * `he-x-NoNikud` - Hebrew without nikud (e.g. \"שבת\")\n */\nclass Locale {\n  /**\n   * Returns translation only if `locale` offers a non-empty translation for `id`.\n   * Otherwise, returns `undefined`.\n   * @param id Message ID to translate\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static lookupTranslation(id, locale) {\n    const loc = typeof locale === 'string' && locales.get(locale.toLowerCase()) || activeLocale;\n    const array = loc[id];\n    if ((array === null || array === void 0 ? void 0 : array.length) && array[0].length) {\n      return array[0];\n    }\n    return undefined;\n  }\n  /**\n   * By default, if no translation was found, returns `id`.\n   * @param id Message ID to translate\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static gettext(id, locale) {\n    const text = this.lookupTranslation(id, locale);\n    if (typeof text === 'undefined') {\n      return id;\n    }\n    return text;\n  }\n  /**\n   * Register locale translations.\n   * @param locale Locale name (i.e.: `'he'`, `'fr'`)\n   * @param data parsed data from a `.po` file.\n   */\n  static addLocale(locale, data) {\n    locale = checkLocale(locale);\n    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {\n      throw new TypeError(`Locale '${locale}' invalid compact format`);\n    }\n    locales.set(locale, data.contexts['']);\n  }\n  /**\n   * Adds a translation to `locale`, replacing any previous translation.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`).\n   * @param id Message ID to translate\n   * @param translation Translation text\n   */\n  static addTranslation(locale, id, translation) {\n    const loc = getExistingLocale(locale);\n    if (typeof id !== 'string' || id.length === 0) {\n      throw new TypeError(`Invalid id string: ${id}`);\n    }\n    const isArray = Array.isArray(translation);\n    if (isArray) {\n      const t0 = translation[0];\n      if (typeof t0 !== 'string' || t0.length === 0) {\n        throw new TypeError(`Invalid translation array: ${translation}`);\n      }\n    } else if (typeof translation !== 'string') {\n      throw new TypeError(`Invalid translation string: ${translation}`);\n    }\n    loc[id] = isArray ? translation : [translation];\n  }\n  /**\n   * Adds multiple translations to `locale`, replacing any previous translations.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`).\n   * @param data parsed data from a `.po` file.\n   */\n  static addTranslations(locale, data) {\n    const loc = getExistingLocale(locale);\n    if (typeof data.contexts !== 'object' || typeof data.contexts[''] !== 'object') {\n      throw new TypeError(`Locale '${locale}' invalid compact format`);\n    }\n    const ctx = data.contexts[''];\n    Object.assign(loc, ctx);\n  }\n  /**\n   * Activates a locale. Throws an error if the locale has not been previously added.\n   * After setting the locale to be used, all strings marked for translations\n   * will be represented by the corresponding translation in the specified locale.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`)\n   * @deprecated\n   */\n  static useLocale(locale) {\n    const locale0 = checkLocale(locale);\n    const obj = getExistingLocale(locale0);\n    activeName = alias[locale0] || locale0;\n    activeLocale = obj;\n    return activeLocale;\n  }\n  /**\n   * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')\n   * @deprecated\n   */\n  static getLocaleName() {\n    return activeName;\n  }\n  /**\n   * Returns the names of registered locales\n   */\n  static getLocaleNames() {\n    const keys = Array.from(locales.keys());\n    return keys.sort((a, b) => a.localeCompare(b));\n  }\n  /**\n   * Renders a number in ordinal, such as 1st, 2nd or 3rd\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static ordinal(n, locale) {\n    const locale1 = locale === null || locale === void 0 ? void 0 : locale.toLowerCase();\n    const locale0 = locale1 || activeName;\n    if (!locale0) {\n      return getEnOrdinal(n);\n    }\n    switch (locale0) {\n      case 'en':\n      case 's':\n      case 'a':\n        return getEnOrdinal(n);\n      case 'es':\n        return n + 'º';\n      case 'h':\n      case 'he':\n      case 'he-x-nonikud':\n        return String(n);\n    }\n    if (locale0.startsWith('ashkenazi')) {\n      return getEnOrdinal(n);\n    }\n    return n + '.';\n  }\n  /**\n   * Removes nekudot from Hebrew string\n   */\n  static hebrewStripNikkud(str) {\n    return str.replace(/[\\u0590-\\u05bd]/g, '').replace(/[\\u05bf-\\u05c7]/g, '');\n  }\n}\nLocale.addLocale('en', noopLocale);\nLocale.addLocale('s', noopLocale);\nLocale.addLocale('', noopLocale);\nLocale.useLocale('en');\n/* Ashkenazic transliterations */\nLocale.addLocale('ashkenazi', poAshkenazi);\nLocale.addLocale('a', poAshkenazi);\n/* Hebrew with nikkud */\nLocale.addLocale('he', poHe);\nLocale.addLocale('h', poHe);\n/* Hebrew without nikkud */\nconst heStrs = poHe.contexts[''];\nconst heNoNikud = {};\nfor (const [key, val] of Object.entries(heStrs)) {\n  heNoNikud[key] = [Locale.hebrewStripNikkud(val[0])];\n}\nconst poHeNoNikud = {\n  headers: poHe.headers,\n  contexts: {\n    '': heNoNikud\n  }\n};\nLocale.addLocale('he-x-NoNikud', poHeNoNikud);\nexport { Locale };","map":{"version":3,"names":["noopLocale","headers","contexts","alias","h","a","s","locales","Map","activeLocale","activeName","getEnOrdinal","n","v","checkLocale","locale","TypeError","toLowerCase","getExistingLocale","locale1","loc","get","RangeError","Locale","lookupTranslation","id","array","length","undefined","gettext","text","addLocale","data","set","addTranslation","translation","isArray","Array","t0","addTranslations","ctx","Object","assign","useLocale","locale0","obj","getLocaleName","getLocaleNames","keys","from","sort","b","localeCompare","ordinal","String","startsWith","hebrewStripNikkud","str","replace","poAshkenazi","poHe","heStrs","heNoNikud","key","val","entries","poHeNoNikud"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/locale.ts"],"sourcesContent":["import poAshkenazi from './ashkenazi.po';\nimport poHe from './he.po';\n\nexport interface Headers {\n  'content-type'?: string;\n  'plural-forms'?: string;\n}\n\nexport interface StringArrayMap {\n  [key: string]: string[];\n}\n\nexport interface LocaleData {\n  headers: Headers;\n  contexts: {[key: string]: StringArrayMap};\n}\n\nconst noopLocale: LocaleData = {\n  headers: {'plural-forms': 'nplurals=2; plural=(n!=1);'},\n  contexts: {'': {}},\n} as const;\n\ninterface StringProps {\n  [key: string]: string;\n}\n\nconst alias: StringProps = {\n  h: 'he',\n  a: 'ashkenazi',\n  s: 'en',\n  '': 'en',\n} as const;\n\n/** @private */\nconst locales = new Map<string, StringArrayMap>();\n/** @private */\nlet activeLocale: StringArrayMap;\n/** @private */\nlet activeName: string;\n\n/** @private */\nfunction getEnOrdinal(n: number): string {\n  const s = ['th', 'st', 'nd', 'rd'];\n  const v = n % 100;\n  return n + (s[(v - 20) % 10] || s[v] || s[0]);\n}\n\n/** @private */\nfunction checkLocale(locale: string): string {\n  if (typeof locale !== 'string') {\n    throw new TypeError(`Invalid locale name: ${locale}`);\n  }\n  return locale.toLowerCase();\n}\n\n/** @private */\nfunction getExistingLocale(locale: string): StringArrayMap {\n  const locale1 = checkLocale(locale);\n  const loc = locales.get(locale1);\n  if (!loc) {\n    throw new RangeError(`Locale '${locale}' not found`);\n  }\n  return loc;\n}\n\n/**\n * A locale in Hebcal is used for translations/transliterations of\n * holidays. `@hebcal/hdate` supports four locales by default\n * * `en` - default, Sephardic transliterations (e.g. \"Shabbat\")\n * * `ashkenazi` - Ashkenazi transliterations (e.g. \"Shabbos\")\n * * `he` - Hebrew (e.g. \"שַׁבָּת\")\n * * `he-x-NoNikud` - Hebrew without nikud (e.g. \"שבת\")\n */\nexport class Locale {\n  /**\n   * Returns translation only if `locale` offers a non-empty translation for `id`.\n   * Otherwise, returns `undefined`.\n   * @param id Message ID to translate\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static lookupTranslation(id: string, locale?: string): string | undefined {\n    const loc =\n      (typeof locale === 'string' && locales.get(locale.toLowerCase())) ||\n      activeLocale;\n    const array = loc[id];\n    if (array?.length && array[0].length) {\n      return array[0];\n    }\n    return undefined;\n  }\n\n  /**\n   * By default, if no translation was found, returns `id`.\n   * @param id Message ID to translate\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static gettext(id: string, locale?: string): string {\n    const text = this.lookupTranslation(id, locale);\n    if (typeof text === 'undefined') {\n      return id;\n    }\n    return text;\n  }\n\n  /**\n   * Register locale translations.\n   * @param locale Locale name (i.e.: `'he'`, `'fr'`)\n   * @param data parsed data from a `.po` file.\n   */\n  static addLocale(locale: string, data: LocaleData): void {\n    locale = checkLocale(locale);\n    if (\n      typeof data.contexts !== 'object' ||\n      typeof data.contexts[''] !== 'object'\n    ) {\n      throw new TypeError(`Locale '${locale}' invalid compact format`);\n    }\n    locales.set(locale, data.contexts['']);\n  }\n\n  /**\n   * Adds a translation to `locale`, replacing any previous translation.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`).\n   * @param id Message ID to translate\n   * @param translation Translation text\n   */\n  static addTranslation(\n    locale: string,\n    id: string,\n    translation: string | string[]\n  ): void {\n    const loc = getExistingLocale(locale);\n    if (typeof id !== 'string' || id.length === 0) {\n      throw new TypeError(`Invalid id string: ${id}`);\n    }\n    const isArray = Array.isArray(translation);\n    if (isArray) {\n      const t0 = translation[0];\n      if (typeof t0 !== 'string' || t0.length === 0) {\n        throw new TypeError(`Invalid translation array: ${translation}`);\n      }\n    } else if (typeof translation !== 'string') {\n      throw new TypeError(`Invalid translation string: ${translation}`);\n    }\n    loc[id] = isArray ? translation : [translation];\n  }\n  /**\n   * Adds multiple translations to `locale`, replacing any previous translations.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`).\n   * @param data parsed data from a `.po` file.\n   */\n  static addTranslations(locale: string, data: LocaleData) {\n    const loc = getExistingLocale(locale);\n    if (\n      typeof data.contexts !== 'object' ||\n      typeof data.contexts[''] !== 'object'\n    ) {\n      throw new TypeError(`Locale '${locale}' invalid compact format`);\n    }\n    const ctx = data.contexts[''];\n    Object.assign(loc, ctx);\n  }\n  /**\n   * Activates a locale. Throws an error if the locale has not been previously added.\n   * After setting the locale to be used, all strings marked for translations\n   * will be represented by the corresponding translation in the specified locale.\n   * @param locale Locale name (i.e: `'he'`, `'fr'`)\n   * @deprecated\n   */\n  static useLocale(locale: string): StringArrayMap {\n    const locale0 = checkLocale(locale);\n    const obj = getExistingLocale(locale0);\n    activeName = alias[locale0] || locale0;\n    activeLocale = obj;\n    return activeLocale;\n  }\n\n  /**\n   * Returns the name of the active locale (i.e. 'he', 'ashkenazi', 'fr')\n   * @deprecated\n   */\n  static getLocaleName(): string {\n    return activeName;\n  }\n\n  /**\n   * Returns the names of registered locales\n   */\n  static getLocaleNames(): string[] {\n    const keys = Array.from(locales.keys());\n    return keys.sort((a, b) => a.localeCompare(b));\n  }\n\n  /**\n   * Renders a number in ordinal, such as 1st, 2nd or 3rd\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale.\n   */\n  static ordinal(n: number, locale?: string): string {\n    const locale1 = locale?.toLowerCase();\n    const locale0 = locale1 || activeName;\n    if (!locale0) {\n      return getEnOrdinal(n);\n    }\n    switch (locale0) {\n      case 'en':\n      case 's':\n      case 'a':\n        return getEnOrdinal(n);\n      case 'es':\n        return n + 'º';\n      case 'h':\n      case 'he':\n      case 'he-x-nonikud':\n        return String(n);\n      default:\n        break;\n    }\n    if (locale0.startsWith('ashkenazi')) {\n      return getEnOrdinal(n);\n    }\n    return n + '.';\n  }\n\n  /**\n   * Removes nekudot from Hebrew string\n   */\n  static hebrewStripNikkud(str: string): string {\n    return str.replace(/[\\u0590-\\u05bd]/g, '').replace(/[\\u05bf-\\u05c7]/g, '');\n  }\n}\n\nLocale.addLocale('en', noopLocale);\nLocale.addLocale('s', noopLocale);\nLocale.addLocale('', noopLocale);\nLocale.useLocale('en');\n\n/* Ashkenazic transliterations */\nLocale.addLocale('ashkenazi', poAshkenazi);\nLocale.addLocale('a', poAshkenazi);\n\n/* Hebrew with nikkud */\nLocale.addLocale('he', poHe);\nLocale.addLocale('h', poHe);\n\n/* Hebrew without nikkud */\nconst heStrs = poHe.contexts[''];\nconst heNoNikud: StringArrayMap = {};\nfor (const [key, val] of Object.entries(heStrs)) {\n  heNoNikud[key] = [Locale.hebrewStripNikkud(val[0])];\n}\nconst poHeNoNikud: LocaleData = {\n  headers: poHe.headers,\n  contexts: {'': heNoNikud},\n} as const;\nLocale.addLocale('he-x-NoNikud', poHeNoNikud);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}