{"ast":null,"code":"/*! @hebcal/core v5.9.0, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport 'temporal-polyfill/global';\nimport { NOAACalculator } from '@hebcal/noaa';\nimport { getTimezoneOffset, pad2, getPseudoISO, HDate, isDate } from '@hebcal/hdate';\n\n/**\n * @private\n */\nfunction zdtToDate(zdt) {\n  if (zdt === null) {\n    return new Date(NaN);\n  }\n  const res = new Date(zdt.epochMilliseconds);\n  res.setMilliseconds(0);\n  return res;\n}\nfunction getDate(date) {\n  if (isDate(date)) return date;\n  if (HDate.isHDate(date)) return date.greg();\n  throw new TypeError(`invalid date: ${date}`);\n}\n/**\n * Calculate halachic times (zmanim / זְמַנִּים) for a given day and location.\n * Calculations are available for tzeit / tzais (nightfall),\n * shkiah (sunset) and more.\n *\n * Zmanim are estimated using an algorithm published by the US National Oceanic\n * and Atmospheric Administration. The NOAA solar calculator is based on equations\n * from _Astronomical Algorithms_ by Jean Meeus.\n *\n * The sunrise and sunset results are theoretically accurate to within a minute for\n * locations between +/- 72° latitude, and within 10 minutes outside of those latitudes.\n * However, due to variations in atmospheric composition, temperature, pressure and\n * conditions, observed values may vary from calculations.\n * https://gml.noaa.gov/grad/solcalc/calcdetails.html\n *\n * @example\n * const {GeoLocation, Zmanim} = require('@hebcal/core');\n * const latitude = 41.822232;\n * const longitude = -71.448292;\n * const tzid = 'America/New_York';\n * const friday = new Date(2023, 8, 8);\n * const gloc = new GeoLocation(null, latitude, longitude, 0, tzid);\n * const zmanim = new Zmanim(gloc, friday, false);\n * const candleLighting = zmanim.sunsetOffset(-18, true);\n * const timeStr = Zmanim.formatISOWithTimeZone(tzid, candleLighting);\n */\nclass Zmanim {\n  /**\n   * Initialize a Zmanim instance.\n   * @param gloc GeoLocation including latitude, longitude, and timezone\n   * @param date Regular or Hebrew Date. If `date` is a regular `Date`,\n   *    hours, minutes, seconds and milliseconds are ignored.\n   * @param useElevation use elevation for calculations (default `false`).\n   *    If `true`, use elevation to affect the calculation of all sunrise/sunset based\n   *    zmanim. Note: there are some zmanim such as degree-based zmanim that are driven\n   *    by the amount of light in the sky and are not impacted by elevation.\n   *    These zmanim intentionally do not support elevation adjustment.\n   */\n  constructor(gloc, date, useElevation) {\n    const dt = getDate(date);\n    this.date = dt;\n    this.gloc = gloc;\n    const plainDate = Temporal.PlainDate.from({\n      year: dt.getFullYear(),\n      month: dt.getMonth() + 1,\n      day: dt.getDate()\n    });\n    this.noaa = new NOAACalculator(gloc, plainDate);\n    this.useElevation = Boolean(useElevation);\n  }\n  /**\n   * Returns `true` if elevation adjustment is enabled\n   * for zmanim support elevation adjustment\n   */\n  getUseElevation() {\n    return this.useElevation;\n  }\n  /**\n   * Enables or disables elevation adjustment for zmanim support elevation adjustment\n   * @param useElevation\n   */\n  setUseElevation(useElevation) {\n    this.useElevation = useElevation;\n  }\n  /**\n   * Convenience function to get the time when sun is above or below the horizon\n   * for a certain angle (in degrees).\n   * This function does not support elevation adjustment.\n   * @param angle\n   * @param rising\n   */\n  timeAtAngle(angle, rising) {\n    const offsetZenith = 90 + angle;\n    const zdt = rising ? this.noaa.getSunriseOffsetByDegrees(offsetZenith) : this.noaa.getSunsetOffsetByDegrees(offsetZenith);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sunrise() {\n    const zdt = this.useElevation ? this.noaa.getSunrise() : this.noaa.getSeaLevelSunrise();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon).\n   * This function does not support elevation adjustment.\n   */\n  seaLevelSunrise() {\n    const zdt = this.noaa.getSeaLevelSunrise();\n    return zdtToDate(zdt);\n  }\n  /**\n   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sunset() {\n    const zdt = this.useElevation ? this.noaa.getSunset() : this.noaa.getSeaLevelSunset();\n    return zdtToDate(zdt);\n  }\n  /**\n   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).\n   * This function does not support elevation adjustment.\n   */\n  seaLevelSunset() {\n    const zdt = this.noaa.getSeaLevelSunset();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Civil dawn; Sun is 6° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  dawn() {\n    const zdt = this.noaa.getBeginCivilTwilight();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Civil dusk; Sun is 6° below the horizon in the evening.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  dusk() {\n    const zdt = this.noaa.getEndCivilTwilight();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Returns sunset for the previous day.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  gregEve() {\n    const prev = new Date(this.date);\n    prev.setDate(prev.getDate() - 1);\n    const zman = new Zmanim(this.gloc, prev, this.useElevation);\n    return zman.sunset();\n  }\n  /**\n   * @private\n   */\n  nightHour() {\n    return (this.sunrise().getTime() - this.gregEve().getTime()) / 12; // ms in hour\n  }\n  /**\n   * Midday – Chatzot; Sunrise plus 6 halachic hours\n   */\n  chatzot() {\n    const startOfDay = this.noaa.getSeaLevelSunrise();\n    const endOfDay = this.noaa.getSeaLevelSunset();\n    const zdt = this.noaa.getSunTransit(startOfDay, endOfDay);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Midnight – Chatzot; Sunset plus 6 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  chatzotNight() {\n    return new Date(this.sunrise().getTime() - this.nightHour() * 6);\n  }\n  /**\n   * Dawn – Alot haShachar; Sun is 16.1° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  alotHaShachar() {\n    return this.timeAtAngle(16.1, true);\n  }\n  /**\n   * Earliest talis & tefillin – Misheyakir; Sun is 11.5° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  misheyakir() {\n    return this.timeAtAngle(11.5, true);\n  }\n  /**\n   * Earliest talis & tefillin – Misheyakir Machmir; Sun is 10.2° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  misheyakirMachmir() {\n    return this.timeAtAngle(10.2, true);\n  }\n  /**\n   * Utility method for using elevation-aware sunrise/sunset\n   * @private\n   * @param hours\n   */\n  getShaahZmanisBasedZman(hours) {\n    const startOfDay = this.useElevation ? this.noaa.getSunrise() : this.noaa.getSeaLevelSunrise();\n    const endOfDay = this.useElevation ? this.noaa.getSunset() : this.noaa.getSeaLevelSunset();\n    const temporalHour = this.noaa.getTemporalHour(startOfDay, endOfDay);\n    const offset = Math.round(temporalHour * hours);\n    const zdt = NOAACalculator.getTimeOffset(startOfDay, offset);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Latest Shema (Gra); Sunrise plus 3 halachic hours, according to the Gra.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sofZmanShma() {\n    // Gra\n    return this.getShaahZmanisBasedZman(3);\n  }\n  /**\n   * Latest Shacharit (Gra); Sunrise plus 4 halachic hours, according to the Gra.\n   *\n   * This method returns the latest *zman tfila* (time to recite shema in the morning)\n   * that is 4 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   *\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sofZmanTfilla() {\n    // Gra\n    return this.getShaahZmanisBasedZman(4);\n  }\n  /**\n   * Returns an array with alot (Date) and ms in hour (number)\n   * @private\n   */\n  getTemporalHour72(forceSeaLevel) {\n    const alot72 = this.sunriseOffset(-72, false, forceSeaLevel);\n    const tzeit72 = this.sunsetOffset(72, false, forceSeaLevel);\n    const temporalHour = (tzeit72.getTime() - alot72.getTime()) / 12;\n    return [alot72, temporalHour];\n  }\n  /**\n   * Returns an array with alot (Date) and ms in hour (number)\n   * @private\n   */\n  getTemporalHourByDeg(angle) {\n    const alot = this.timeAtAngle(angle, true);\n    const tzeit = this.timeAtAngle(angle, false);\n    const temporalHour = (tzeit.getTime() - alot.getTime()) / 12;\n    return [alot, temporalHour];\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn being fixed 72 minutes before sea-level sunrise, and nightfall is fixed\n   * 72 minutes after sea-level sunset.\n   */\n  sofZmanShmaMGA() {\n    // Magen Avraham\n    const [alot72, temporalHour] = this.getTemporalHour72(true);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 16.1° below the horizon.\n   */\n  sofZmanShmaMGA16Point1() {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 19.8° below the horizon.\n   *\n   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem\n   * around the equinox / equilux which calculates to 19.8° below geometric zenith.\n   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/\n   */\n  sofZmanShmaMGA19Point8() {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham\n   */\n  sofZmanTfillaMGA() {\n    // Magen Avraham\n    const [alot72, temporalHour] = this.getTemporalHour72(true);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 16.1° below the horizon.\n   */\n  sofZmanTfillaMGA16Point1() {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 19.8° below the horizon.\n   *\n   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem\n   * around the equinox / equilux which calculates to 19.8° below geometric zenith.\n   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/\n   */\n  sofZmanTfillaMGA19Point8() {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Earliest Mincha – Mincha Gedola (GRA); Sunrise plus 6.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns the latest mincha gedola, the earliest time one can pray mincha\n   * that is 6.5 shaos zmaniyos (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   *\n   * The Ramba\"m is of the opinion that it is better to delay *mincha* until\n   * *mincha ketana* while the Ra\"sh, Tur, GRA and others are of the\n   * opinion that *mincha* can be prayed *lechatchila* starting at *mincha gedola*.\n   */\n  minchaGedola() {\n    return this.getShaahZmanisBasedZman(6.5);\n  }\n  /**\n   * Earliest Mincha – Mincha Gedola (MGA); Sunrise plus 6.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns the time of *mincha gedola* according to the Magen Avraham\n   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.\n   * This is the earliest time to pray *mincha*.\n   */\n  minchaGedolaMGA() {\n    const [alot72, temporalHour] = this.getTemporalHour72(false);\n    const offset = Math.floor(6.5 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Preferable earliest time to recite Minchah – Mincha Ketana; Sunrise plus 9.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns *mincha ketana*, the preferred earliest time to pray *mincha* in the\n   * opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others,\n   * that is 9.5 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   */\n  minchaKetana() {\n    return this.getShaahZmanisBasedZman(9.5);\n  }\n  /**\n   * This method returns the time of *mincha ketana* according to the Magen Avraham\n   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.\n   * This is the preferred earliest time to pray *mincha* according to the opinion of\n   * the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others.\n   *\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  minchaKetanaMGA() {\n    const [alot72, temporalHour] = this.getTemporalHour72(false);\n    return new Date(alot72.getTime() + Math.floor(9.5 * temporalHour));\n  }\n  /**\n   * Plag haMincha; Sunrise plus 10.75 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  plagHaMincha() {\n    return this.getShaahZmanisBasedZman(10.75);\n  }\n  /**\n   * @param [angle=8.5] optional time for solar depression.\n   *   Default is 8.5 degrees for 3 small stars, use 7.083 degrees for 3 medium-sized stars.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  tzeit(angle = 8.5) {\n    return this.timeAtAngle(angle, false);\n  }\n  /**\n   * Alias for sunrise\n   */\n  neitzHaChama() {\n    return this.sunrise();\n  }\n  /**\n   * Alias for sunset\n   */\n  shkiah() {\n    return this.sunset();\n  }\n  /**\n   * Rabbeinu Tam holds that bein hashmashos is a specific time\n   * between sunset and tzeis hakochavim.\n   * One opinion on how to calculate this time is that\n   * it is 13.5 minutes before tzies 7.083.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  beinHaShmashos() {\n    const tzeit = this.tzeit(7.083);\n    const millis = tzeit.getTime();\n    if (isNaN(millis)) {\n      return tzeit;\n    }\n    return new Date(millis - 13.5 * 60 * 1000);\n  }\n  /**\n   * Uses timeFormat to return a date like '20:34'\n   */\n  static formatTime(dt, timeFormat) {\n    const time = timeFormat.format(dt);\n    const hm = time.split(':');\n    if (hm[0] === '24') {\n      return '00:' + hm[1];\n    }\n    return time;\n  }\n  /**\n   * Discards seconds, rounding to nearest minute.\n   * @param dt\n   */\n  static roundTime(dt) {\n    const millis = dt.getTime();\n    if (isNaN(millis)) {\n      return dt;\n    }\n    // Round up to next minute if needed\n    const millisOnly = dt.getMilliseconds();\n    const seconds = dt.getSeconds();\n    if (seconds === 0 && millisOnly === 0) {\n      return dt;\n    }\n    const secAndMillis = seconds * 1000 + millisOnly;\n    const delta = secAndMillis >= 30000 ? 60000 - secAndMillis : -1 * secAndMillis;\n    return new Date(millis + delta);\n  }\n  /**\n   * Get offset string (like \"+05:00\" or \"-08:00\") from tzid (like \"Europe/Moscow\")\n   * @param tzid\n   * @param date\n   */\n  static timeZoneOffset(tzid, date) {\n    const offset = getTimezoneOffset(tzid, date);\n    const offsetAbs = Math.abs(offset);\n    const hours = Math.floor(offsetAbs / 60);\n    const minutes = offsetAbs % 60;\n    return (offset < 0 ? '+' : '-') + pad2(hours) + ':' + pad2(minutes);\n  }\n  /**\n   * Returns a string like \"2022-04-01T13:06:00-11:00\"\n   * @param tzid\n   * @param date\n   */\n  static formatISOWithTimeZone(tzid, date) {\n    if (isNaN(date.getTime())) {\n      return '0000-00-00T00:00:00Z';\n    }\n    return getPseudoISO(tzid, date).substring(0, 19) + Zmanim.timeZoneOffset(tzid, date);\n  }\n  /**\n   * Returns sunrise + `offset` minutes (either positive or negative).\n   * If elevation is enabled, this function will include elevation in the calculation\n   *  unless `forceSeaLevel` is `true`.\n   * @param offset minutes\n   * @param roundMinute round time to nearest minute (default true)\n   * @param forceSeaLevel use sea-level sunrise (default false)\n   */\n  sunriseOffset(offset, roundMinute = true, forceSeaLevel = false) {\n    const sunrise = forceSeaLevel ? this.seaLevelSunrise() : this.sunrise();\n    if (isNaN(sunrise.getTime())) {\n      return sunrise;\n    }\n    if (roundMinute) {\n      // For positive offsets only, round up to next minute if needed\n      if (offset > 0 && sunrise.getSeconds() >= 30) {\n        offset++;\n      }\n      sunrise.setSeconds(0, 0);\n    }\n    return new Date(sunrise.getTime() + offset * 60 * 1000);\n  }\n  /**\n   * Returns sunset + `offset` minutes (either positive or negative).\n   * If elevation is enabled, this function will include elevation in the calculation\n   *  unless `forceSeaLevel` is `true`.\n   * @param offset minutes\n   * @param roundMinute round time to nearest minute (default true)\n   * @param forceSeaLevel use sea-level sunset (default false)\n   */\n  sunsetOffset(offset, roundMinute = true, forceSeaLevel = false) {\n    const sunset = forceSeaLevel ? this.seaLevelSunset() : this.sunset();\n    if (isNaN(sunset.getTime())) {\n      return sunset;\n    }\n    if (roundMinute) {\n      // For Havdalah only, round up to next minute if needed\n      if (offset > 0 && sunset.getSeconds() >= 30) {\n        offset++;\n      }\n      sunset.setSeconds(0, 0);\n    }\n    return new Date(sunset.getTime() + offset * 60 * 1000);\n  }\n  /**\n   * Returns the Hebrew date relative to the specified location and Gregorian date,\n   * taking into consideration whether the time is before or after sunset.\n   *\n   * For example, if the given date and is `2024-09-22T10:35` (before sunset), and\n   * sunset for the specified location is **19:04**, then this function would\n   * return a Hebrew date of `19th of Elul, 5784`.\n   * If the given date is the same Gregorian day after sunset\n   * (for example `2024-09-22T20:07`), this function would return a\n   * Hebrew date of `20th of Elul, 5784`.\n   * @example\n   * const {GeoLocation, Zmanim, HDate} = require('@hebcal/core');\n   * const latitude = 48.85341;\n   * const longitude = 2.3488;\n   * const timezone = 'Europe/Paris';\n   * const gloc = new GeoLocation(null, latitude, longitude, 0, timezone);\n   * const before = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T17:38:46.123Z'), false);\n   * console.log(before.toString()); // '19 Elul 5784'\n   * const after = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T23:45:18.345Z'), false);\n   * console.log(after.toString()); // '20 Elul 5784'\n   */\n  static makeSunsetAwareHDate(gloc, date, useElevation) {\n    const zmanim = new Zmanim(gloc, date, useElevation);\n    const sunset = zmanim.sunset();\n    let hd = new HDate(date);\n    const sunsetMillis = sunset.getTime();\n    if (isNaN(sunsetMillis)) {\n      return hd;\n    }\n    if (date.getTime() >= sunsetMillis) {\n      hd = hd.next();\n    }\n    return hd;\n  }\n}\nexport { Zmanim };","map":{"version":3,"names":["zdtToDate","zdt","Date","NaN","res","epochMilliseconds","setMilliseconds","getDate","date","isDate","HDate","isHDate","greg","TypeError","Zmanim","constructor","gloc","useElevation","dt","plainDate","Temporal","PlainDate","from","year","getFullYear","month","getMonth","day","noaa","NOAACalculator","Boolean","getUseElevation","setUseElevation","timeAtAngle","angle","rising","offsetZenith","getSunriseOffsetByDegrees","getSunsetOffsetByDegrees","sunrise","getSunrise","getSeaLevelSunrise","seaLevelSunrise","sunset","getSunset","getSeaLevelSunset","seaLevelSunset","dawn","getBeginCivilTwilight","dusk","getEndCivilTwilight","gregEve","prev","setDate","zman","nightHour","getTime","chatzot","startOfDay","endOfDay","getSunTransit","chatzotNight","alotHaShachar","misheyakir","misheyakirMachmir","getShaahZmanisBasedZman","hours","temporalHour","getTemporalHour","offset","Math","round","getTimeOffset","sofZmanShma","sofZmanTfilla","getTemporalHour72","forceSeaLevel","alot72","sunriseOffset","tzeit72","sunsetOffset","getTemporalHourByDeg","alot","tzeit","sofZmanShmaMGA","floor","sofZmanShmaMGA16Point1","sofZmanShmaMGA19Point8","sofZmanTfillaMGA","sofZmanTfillaMGA16Point1","sofZmanTfillaMGA19Point8","minchaGedola","minchaGedolaMGA","minchaKetana","minchaKetanaMGA","plagHaMincha","neitzHaChama","shkiah","beinHaShmashos","millis","isNaN","formatTime","timeFormat","time","format","hm","split","roundTime","millisOnly","getMilliseconds","seconds","getSeconds","secAndMillis","delta","timeZoneOffset","tzid","getTimezoneOffset","offsetAbs","abs","minutes","pad2","formatISOWithTimeZone","getPseudoISO","substring","roundMinute","setSeconds","makeSunsetAwareHDate","zmanim","hd","sunsetMillis","next"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/zmanim.ts"],"sourcesContent":["import 'temporal-polyfill/global';\nimport {GeoLocation, NOAACalculator} from '@hebcal/noaa';\nimport {\n  HDate,\n  getPseudoISO,\n  getTimezoneOffset,\n  isDate,\n  pad2,\n} from '@hebcal/hdate';\n\n/**\n * @private\n */\nfunction zdtToDate(zdt: Temporal.ZonedDateTime | null): Date {\n  if (zdt === null) {\n    return new Date(NaN);\n  }\n  const res = new Date(zdt.epochMilliseconds);\n  res.setMilliseconds(0);\n  return res;\n}\n\nfunction getDate(date: Date | HDate): Date {\n  if (isDate(date)) return date as Date;\n  if (HDate.isHDate(date)) return (date as HDate).greg();\n  throw new TypeError(`invalid date: ${date}`);\n}\n\n/**\n * Calculate halachic times (zmanim / זְמַנִּים) for a given day and location.\n * Calculations are available for tzeit / tzais (nightfall),\n * shkiah (sunset) and more.\n *\n * Zmanim are estimated using an algorithm published by the US National Oceanic\n * and Atmospheric Administration. The NOAA solar calculator is based on equations\n * from _Astronomical Algorithms_ by Jean Meeus.\n *\n * The sunrise and sunset results are theoretically accurate to within a minute for\n * locations between +/- 72° latitude, and within 10 minutes outside of those latitudes.\n * However, due to variations in atmospheric composition, temperature, pressure and\n * conditions, observed values may vary from calculations.\n * https://gml.noaa.gov/grad/solcalc/calcdetails.html\n *\n * @example\n * const {GeoLocation, Zmanim} = require('@hebcal/core');\n * const latitude = 41.822232;\n * const longitude = -71.448292;\n * const tzid = 'America/New_York';\n * const friday = new Date(2023, 8, 8);\n * const gloc = new GeoLocation(null, latitude, longitude, 0, tzid);\n * const zmanim = new Zmanim(gloc, friday, false);\n * const candleLighting = zmanim.sunsetOffset(-18, true);\n * const timeStr = Zmanim.formatISOWithTimeZone(tzid, candleLighting);\n */\nexport class Zmanim {\n  private readonly date: Date;\n  private readonly gloc: GeoLocation;\n  private readonly noaa: NOAACalculator;\n  private useElevation: boolean;\n  /**\n   * Initialize a Zmanim instance.\n   * @param gloc GeoLocation including latitude, longitude, and timezone\n   * @param date Regular or Hebrew Date. If `date` is a regular `Date`,\n   *    hours, minutes, seconds and milliseconds are ignored.\n   * @param useElevation use elevation for calculations (default `false`).\n   *    If `true`, use elevation to affect the calculation of all sunrise/sunset based\n   *    zmanim. Note: there are some zmanim such as degree-based zmanim that are driven\n   *    by the amount of light in the sky and are not impacted by elevation.\n   *    These zmanim intentionally do not support elevation adjustment.\n   */\n  constructor(gloc: GeoLocation, date: Date | HDate, useElevation: boolean) {\n    const dt = getDate(date);\n    this.date = dt;\n    this.gloc = gloc;\n    const plainDate = Temporal.PlainDate.from({\n      year: dt.getFullYear(),\n      month: dt.getMonth() + 1,\n      day: dt.getDate(),\n    });\n    this.noaa = new NOAACalculator(gloc, plainDate);\n    this.useElevation = Boolean(useElevation);\n  }\n  /**\n   * Returns `true` if elevation adjustment is enabled\n   * for zmanim support elevation adjustment\n   */\n  getUseElevation(): boolean {\n    return this.useElevation;\n  }\n  /**\n   * Enables or disables elevation adjustment for zmanim support elevation adjustment\n   * @param useElevation\n   */\n  setUseElevation(useElevation: boolean) {\n    this.useElevation = useElevation;\n  }\n  /**\n   * Convenience function to get the time when sun is above or below the horizon\n   * for a certain angle (in degrees).\n   * This function does not support elevation adjustment.\n   * @param angle\n   * @param rising\n   */\n  timeAtAngle(angle: number, rising: boolean): Date {\n    const offsetZenith = 90 + angle;\n    const zdt = rising\n      ? this.noaa.getSunriseOffsetByDegrees(offsetZenith)\n      : this.noaa.getSunsetOffsetByDegrees(offsetZenith);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon)\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sunrise(): Date {\n    const zdt = this.useElevation\n      ? this.noaa.getSunrise()\n      : this.noaa.getSeaLevelSunrise();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Upper edge of the Sun appears over the eastern horizon in the morning (0.833° above horizon).\n   * This function does not support elevation adjustment.\n   */\n  seaLevelSunrise(): Date {\n    const zdt = this.noaa.getSeaLevelSunrise();\n    return zdtToDate(zdt);\n  }\n  /**\n   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sunset(): Date {\n    const zdt = this.useElevation\n      ? this.noaa.getSunset()\n      : this.noaa.getSeaLevelSunset();\n    return zdtToDate(zdt);\n  }\n  /**\n   * When the upper edge of the Sun disappears below the horizon (0.833° below horizon).\n   * This function does not support elevation adjustment.\n   */\n  seaLevelSunset(): Date {\n    const zdt = this.noaa.getSeaLevelSunset();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Civil dawn; Sun is 6° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  dawn(): Date {\n    const zdt = this.noaa.getBeginCivilTwilight();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Civil dusk; Sun is 6° below the horizon in the evening.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  dusk(): Date {\n    const zdt = this.noaa.getEndCivilTwilight();\n    return zdtToDate(zdt);\n  }\n  /**\n   * Returns sunset for the previous day.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  gregEve(): Date {\n    const prev = new Date(this.date);\n    prev.setDate(prev.getDate() - 1);\n    const zman = new Zmanim(this.gloc, prev, this.useElevation);\n    return zman.sunset();\n  }\n  /**\n   * @private\n   */\n  nightHour(): number {\n    return (this.sunrise().getTime() - this.gregEve().getTime()) / 12; // ms in hour\n  }\n  /**\n   * Midday – Chatzot; Sunrise plus 6 halachic hours\n   */\n  chatzot(): Date {\n    const startOfDay = this.noaa.getSeaLevelSunrise();\n    const endOfDay = this.noaa.getSeaLevelSunset();\n    const zdt = this.noaa.getSunTransit(startOfDay, endOfDay);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Midnight – Chatzot; Sunset plus 6 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  chatzotNight(): Date {\n    return new Date(this.sunrise().getTime() - this.nightHour() * 6);\n  }\n  /**\n   * Dawn – Alot haShachar; Sun is 16.1° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  alotHaShachar(): Date {\n    return this.timeAtAngle(16.1, true);\n  }\n  /**\n   * Earliest talis & tefillin – Misheyakir; Sun is 11.5° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  misheyakir(): Date {\n    return this.timeAtAngle(11.5, true);\n  }\n  /**\n   * Earliest talis & tefillin – Misheyakir Machmir; Sun is 10.2° below the horizon in the morning.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  misheyakirMachmir(): Date {\n    return this.timeAtAngle(10.2, true);\n  }\n  /**\n   * Utility method for using elevation-aware sunrise/sunset\n   * @private\n   * @param hours\n   */\n  getShaahZmanisBasedZman(hours: number): Date {\n    const startOfDay = this.useElevation\n      ? this.noaa.getSunrise()\n      : this.noaa.getSeaLevelSunrise();\n    const endOfDay = this.useElevation\n      ? this.noaa.getSunset()\n      : this.noaa.getSeaLevelSunset();\n    const temporalHour = this.noaa.getTemporalHour(startOfDay, endOfDay);\n    const offset = Math.round(temporalHour * hours);\n    const zdt = NOAACalculator.getTimeOffset(startOfDay, offset);\n    return zdtToDate(zdt);\n  }\n  /**\n   * Latest Shema (Gra); Sunrise plus 3 halachic hours, according to the Gra.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sofZmanShma(): Date {\n    // Gra\n    return this.getShaahZmanisBasedZman(3);\n  }\n  /**\n   * Latest Shacharit (Gra); Sunrise plus 4 halachic hours, according to the Gra.\n   *\n   * This method returns the latest *zman tfila* (time to recite shema in the morning)\n   * that is 4 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   *\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  sofZmanTfilla(): Date {\n    // Gra\n    return this.getShaahZmanisBasedZman(4);\n  }\n  /**\n   * Returns an array with alot (Date) and ms in hour (number)\n   * @private\n   */\n  getTemporalHour72(forceSeaLevel: boolean): [Date, number] {\n    const alot72 = this.sunriseOffset(-72, false, forceSeaLevel);\n    const tzeit72 = this.sunsetOffset(72, false, forceSeaLevel);\n    const temporalHour = (tzeit72.getTime() - alot72.getTime()) / 12;\n    return [alot72, temporalHour];\n  }\n  /**\n   * Returns an array with alot (Date) and ms in hour (number)\n   * @private\n   */\n  getTemporalHourByDeg(angle: number): [Date, number] {\n    const alot = this.timeAtAngle(angle, true);\n    const tzeit = this.timeAtAngle(angle, false);\n    const temporalHour = (tzeit.getTime() - alot.getTime()) / 12;\n    return [alot, temporalHour];\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn being fixed 72 minutes before sea-level sunrise, and nightfall is fixed\n   * 72 minutes after sea-level sunset.\n   */\n  sofZmanShmaMGA(): Date {\n    // Magen Avraham\n    const [alot72, temporalHour] = this.getTemporalHour72(true);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 16.1° below the horizon.\n   */\n  sofZmanShmaMGA16Point1(): Date {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shema (MGA); Sunrise plus 3 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 19.8° below the horizon.\n   *\n   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem\n   * around the equinox / equilux which calculates to 19.8° below geometric zenith.\n   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/\n   */\n  sofZmanShmaMGA19Point8(): Date {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);\n    const offset = Math.floor(3 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham\n   */\n  sofZmanTfillaMGA(): Date {\n    // Magen Avraham\n    const [alot72, temporalHour] = this.getTemporalHour72(true);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 16.1° below the horizon.\n   */\n  sofZmanTfillaMGA16Point1(): Date {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(16.1);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Latest Shacharit (MGA); Sunrise plus 4 halachic hours, according to Magen Avraham.\n   * Based on the opinion of the MGA that the day is calculated from\n   * dawn to nightfall with both being 19.8° below the horizon.\n   *\n   * This calculation is based on the position of the sun 90 minutes after sunset in Jerusalem\n   * around the equinox / equilux which calculates to 19.8° below geometric zenith.\n   * https://kosherjava.com/2022/01/12/equinox-vs-equilux-zmanim-calculations/\n   */\n  sofZmanTfillaMGA19Point8(): Date {\n    const [alot, temporalHour] = this.getTemporalHourByDeg(19.8);\n    const offset = Math.floor(4 * temporalHour);\n    return new Date(alot.getTime() + offset);\n  }\n  /**\n   * Earliest Mincha – Mincha Gedola (GRA); Sunrise plus 6.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns the latest mincha gedola, the earliest time one can pray mincha\n   * that is 6.5 shaos zmaniyos (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   *\n   * The Ramba\"m is of the opinion that it is better to delay *mincha* until\n   * *mincha ketana* while the Ra\"sh, Tur, GRA and others are of the\n   * opinion that *mincha* can be prayed *lechatchila* starting at *mincha gedola*.\n   */\n  minchaGedola(): Date {\n    return this.getShaahZmanisBasedZman(6.5);\n  }\n  /**\n   * Earliest Mincha – Mincha Gedola (MGA); Sunrise plus 6.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns the time of *mincha gedola* according to the Magen Avraham\n   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.\n   * This is the earliest time to pray *mincha*.\n   */\n  minchaGedolaMGA(): Date {\n    const [alot72, temporalHour] = this.getTemporalHour72(false);\n    const offset = Math.floor(6.5 * temporalHour);\n    return new Date(alot72.getTime() + offset);\n  }\n  /**\n   * Preferable earliest time to recite Minchah – Mincha Ketana; Sunrise plus 9.5 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   *\n   * This method returns *mincha ketana*, the preferred earliest time to pray *mincha* in the\n   * opinion of the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others,\n   * that is 9.5 *shaos zmaniyos* (solar hours) after sunrise or sea level sunrise\n   * (depending on the `useElevation` setting), according\n   * to the [GRA](https://en.wikipedia.org/wiki/Vilna_Gaon).\n   */\n  minchaKetana(): Date {\n    return this.getShaahZmanisBasedZman(9.5);\n  }\n  /**\n   * This method returns the time of *mincha ketana* according to the Magen Avraham\n   * with the day starting 72 minutes before sunrise and ending 72 minutes after sunset.\n   * This is the preferred earliest time to pray *mincha* according to the opinion of\n   * the [Rambam](https://en.wikipedia.org/wiki/Maimonides) and others.\n   *\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  minchaKetanaMGA(): Date {\n    const [alot72, temporalHour] = this.getTemporalHour72(false);\n    return new Date(alot72.getTime() + Math.floor(9.5 * temporalHour));\n  }\n  /**\n   * Plag haMincha; Sunrise plus 10.75 halachic hours.\n   * If elevation is enabled, this function will include elevation in the calculation.\n   */\n  plagHaMincha(): Date {\n    return this.getShaahZmanisBasedZman(10.75);\n  }\n  /**\n   * @param [angle=8.5] optional time for solar depression.\n   *   Default is 8.5 degrees for 3 small stars, use 7.083 degrees for 3 medium-sized stars.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  tzeit(angle = 8.5): Date {\n    return this.timeAtAngle(angle, false);\n  }\n  /**\n   * Alias for sunrise\n   */\n  neitzHaChama(): Date {\n    return this.sunrise();\n  }\n  /**\n   * Alias for sunset\n   */\n  shkiah(): Date {\n    return this.sunset();\n  }\n  /**\n   * Rabbeinu Tam holds that bein hashmashos is a specific time\n   * between sunset and tzeis hakochavim.\n   * One opinion on how to calculate this time is that\n   * it is 13.5 minutes before tzies 7.083.\n   * Because degree-based functions estimate the amount of light in the sky,\n   * the result is not impacted by elevation.\n   */\n  beinHaShmashos(): Date {\n    const tzeit = this.tzeit(7.083);\n    const millis = tzeit.getTime();\n    if (isNaN(millis)) {\n      return tzeit;\n    }\n    return new Date(millis - 13.5 * 60 * 1000);\n  }\n  /**\n   * Uses timeFormat to return a date like '20:34'\n   */\n  static formatTime(dt: Date, timeFormat: Intl.DateTimeFormat): string {\n    const time = timeFormat.format(dt);\n    const hm = time.split(':');\n    if (hm[0] === '24') {\n      return '00:' + hm[1];\n    }\n    return time;\n  }\n\n  /**\n   * Discards seconds, rounding to nearest minute.\n   * @param dt\n   */\n  static roundTime(dt: Date): Date {\n    const millis = dt.getTime();\n    if (isNaN(millis)) {\n      return dt;\n    }\n    // Round up to next minute if needed\n    const millisOnly = dt.getMilliseconds();\n    const seconds = dt.getSeconds();\n    if (seconds === 0 && millisOnly === 0) {\n      return dt;\n    }\n    const secAndMillis = seconds * 1000 + millisOnly;\n    const delta =\n      secAndMillis >= 30000 ? 60000 - secAndMillis : -1 * secAndMillis;\n    return new Date(millis + delta);\n  }\n\n  /**\n   * Get offset string (like \"+05:00\" or \"-08:00\") from tzid (like \"Europe/Moscow\")\n   * @param tzid\n   * @param date\n   */\n  static timeZoneOffset(tzid: string, date: Date): string {\n    const offset = getTimezoneOffset(tzid, date);\n    const offsetAbs = Math.abs(offset);\n    const hours = Math.floor(offsetAbs / 60);\n    const minutes = offsetAbs % 60;\n    return (offset < 0 ? '+' : '-') + pad2(hours) + ':' + pad2(minutes);\n  }\n\n  /**\n   * Returns a string like \"2022-04-01T13:06:00-11:00\"\n   * @param tzid\n   * @param date\n   */\n  static formatISOWithTimeZone(tzid: string, date: Date): string {\n    if (isNaN(date.getTime())) {\n      return '0000-00-00T00:00:00Z';\n    }\n    return (\n      getPseudoISO(tzid, date).substring(0, 19) +\n      Zmanim.timeZoneOffset(tzid, date)\n    );\n  }\n\n  /**\n   * Returns sunrise + `offset` minutes (either positive or negative).\n   * If elevation is enabled, this function will include elevation in the calculation\n   *  unless `forceSeaLevel` is `true`.\n   * @param offset minutes\n   * @param roundMinute round time to nearest minute (default true)\n   * @param forceSeaLevel use sea-level sunrise (default false)\n   */\n  sunriseOffset(\n    offset: number,\n    roundMinute = true,\n    forceSeaLevel = false\n  ): Date {\n    const sunrise = forceSeaLevel ? this.seaLevelSunrise() : this.sunrise();\n    if (isNaN(sunrise.getTime())) {\n      return sunrise;\n    }\n    if (roundMinute) {\n      // For positive offsets only, round up to next minute if needed\n      if (offset > 0 && sunrise.getSeconds() >= 30) {\n        offset++;\n      }\n      sunrise.setSeconds(0, 0);\n    }\n    return new Date(sunrise.getTime() + offset * 60 * 1000);\n  }\n\n  /**\n   * Returns sunset + `offset` minutes (either positive or negative).\n   * If elevation is enabled, this function will include elevation in the calculation\n   *  unless `forceSeaLevel` is `true`.\n   * @param offset minutes\n   * @param roundMinute round time to nearest minute (default true)\n   * @param forceSeaLevel use sea-level sunset (default false)\n   */\n  sunsetOffset(\n    offset: number,\n    roundMinute = true,\n    forceSeaLevel = false\n  ): Date {\n    const sunset = forceSeaLevel ? this.seaLevelSunset() : this.sunset();\n    if (isNaN(sunset.getTime())) {\n      return sunset;\n    }\n    if (roundMinute) {\n      // For Havdalah only, round up to next minute if needed\n      if (offset > 0 && sunset.getSeconds() >= 30) {\n        offset++;\n      }\n      sunset.setSeconds(0, 0);\n    }\n    return new Date(sunset.getTime() + offset * 60 * 1000);\n  }\n  /**\n   * Returns the Hebrew date relative to the specified location and Gregorian date,\n   * taking into consideration whether the time is before or after sunset.\n   *\n   * For example, if the given date and is `2024-09-22T10:35` (before sunset), and\n   * sunset for the specified location is **19:04**, then this function would\n   * return a Hebrew date of `19th of Elul, 5784`.\n   * If the given date is the same Gregorian day after sunset\n   * (for example `2024-09-22T20:07`), this function would return a\n   * Hebrew date of `20th of Elul, 5784`.\n   * @example\n   * const {GeoLocation, Zmanim, HDate} = require('@hebcal/core');\n   * const latitude = 48.85341;\n   * const longitude = 2.3488;\n   * const timezone = 'Europe/Paris';\n   * const gloc = new GeoLocation(null, latitude, longitude, 0, timezone);\n   * const before = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T17:38:46.123Z'), false);\n   * console.log(before.toString()); // '19 Elul 5784'\n   * const after = Zmanim.makeSunsetAwareHDate(gloc, new Date('2024-09-22T23:45:18.345Z'), false);\n   * console.log(after.toString()); // '20 Elul 5784'\n   */\n  static makeSunsetAwareHDate(\n    gloc: GeoLocation,\n    date: Date,\n    useElevation: boolean\n  ): HDate {\n    const zmanim = new Zmanim(gloc, date, useElevation);\n    const sunset = zmanim.sunset();\n    let hd = new HDate(date);\n    const sunsetMillis = sunset.getTime();\n    if (isNaN(sunsetMillis)) {\n      return hd;\n    }\n    if (date.getTime() >= sunsetMillis) {\n      hd = hd.next();\n    }\n    return hd;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}