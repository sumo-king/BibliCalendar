{"ast":null,"code":"/*! @hebcal/hdate v0.13.5, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport { months, hebrew2abs, longCheshvan, abs2hebrew, shortKislev, monthsInYear, isLeapYear } from './hdateBase.js';\nimport { abs2greg, isDate, greg2abs } from './greg.js';\nconst NISAN = months.NISAN;\nconst CHESHVAN = months.CHESHVAN;\nconst KISLEV = months.KISLEV;\nconst TEVET = months.TEVET;\nconst SHVAT = months.SHVAT;\nconst ADAR_I = months.ADAR_I;\nconst ADAR_II = months.ADAR_II;\n/**\n * Returns true if the object is a SimpleHebrewDate\n * @private\n */\nfunction isSimpleHebrewDate(obj) {\n  return typeof obj === 'object' && obj !== null && typeof obj.yy === 'number' && typeof obj.mm === 'number' && typeof obj.dd === 'number';\n}\n/**\n * @private\n */\nfunction toSimpleHebrewDate(obj) {\n  if (isSimpleHebrewDate(obj)) {\n    return obj;\n  } else if (isDate(obj)) {\n    const abs = greg2abs(obj);\n    return abs2hebrew(abs);\n  } else {\n    // typeof obj === 'number'\n    return abs2hebrew(obj);\n  }\n}\n/**\n * Calculates yahrzeit.\n * `hyear` must be after original `date` of death.\n * Returns `undefined` when requested year preceeds or is same as original year.\n *\n * Hebcal uses the algorithm defined in \"Calendrical Calculations\"\n * by Edward M. Reingold and Nachum Dershowitz.\n *\n * The customary anniversary date of a death is more complicated and depends\n * also on the character of the year in which the first anniversary occurs.\n * There are several cases:\n *\n * * If the date of death is Marcheshvan 30, the anniversary in general depends\n *   on the first anniversary; if that first anniversary was not Marcheshvan 30,\n *   use the day before Kislev 1.\n * * If the date of death is Kislev 30, the anniversary in general again depends\n *   on the first anniversary — if that was not Kislev 30, use the day before\n *   Tevet 1.\n * * If the date of death is Adar II, the anniversary is the same day in the\n *   last month of the Hebrew year (Adar or Adar II).\n * * If the date of death is Adar I 30, the anniversary in a Hebrew year that\n *   is not a leap year (in which Adar only has 29 days) is the last day in\n *   Shevat.\n * * In all other cases, use the normal (that is, same month number) anniversary\n *   of the date of death. [Calendrical Calculations p. 113]\n * @example\n * import {getYahrzeit} from '@hebcal/hdate';\n * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'\n * const anniversary = getYahrzeit(5780, dt); // '2/25/2020' == '30 Sh\\'vat 5780'\n * @param hyear Hebrew year\n * @param date Gregorian or Hebrew date of death\n * @returns anniversary occurring in `hyear`\n */\nfunction getYahrzeit(hyear, date) {\n  const hd = getYahrzeitHD(hyear, date);\n  if (typeof hd === 'undefined') {\n    return hd;\n  }\n  return abs2greg(hebrew2abs(hd.yy, hd.mm, hd.dd));\n}\nfunction getYahrzeitHD(hyear, date) {\n  let hDeath = toSimpleHebrewDate(date);\n  if (hyear <= hDeath.yy) {\n    // Hebrew year ${hyear} occurs on or before original date in ${hDeath.yy}\n    return undefined;\n  }\n  if (hDeath.mm === CHESHVAN && hDeath.dd === 30 && !longCheshvan(hDeath.yy + 1)) {\n    // If it's Heshvan 30 it depends on the first anniversary;\n    // if that was not Heshvan 30, use the day before Kislev 1.\n    hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV, 1) - 1);\n  } else if (hDeath.mm === KISLEV && hDeath.dd === 30 && shortKislev(hDeath.yy + 1)) {\n    // If it's Kislev 30 it depends on the first anniversary;\n    // if that was not Kislev 30, use the day before Teveth 1.\n    hDeath = abs2hebrew(hebrew2abs(hyear, TEVET, 1) - 1);\n  } else if (hDeath.mm === ADAR_II) {\n    // If it's Adar II, use the same day in last month of year (Adar or Adar II).\n    hDeath.mm = monthsInYear(hyear);\n  } else if (hDeath.mm === ADAR_I && hDeath.dd === 30 && !isLeapYear(hyear)) {\n    // If it's the 30th in Adar I and year is not a leap year\n    // (so Adar has only 29 days), use the last day in Shevat.\n    hDeath.dd = 30;\n    hDeath.mm = SHVAT;\n  }\n  // In all other cases, use the normal anniversary of the date of death.\n  // advance day to rosh chodesh if needed\n  if (hDeath.mm === CHESHVAN && hDeath.dd === 30 && !longCheshvan(hyear)) {\n    hDeath.mm = KISLEV;\n    hDeath.dd = 1;\n  } else if (hDeath.mm === KISLEV && hDeath.dd === 30 && shortKislev(hyear)) {\n    hDeath.mm = TEVET;\n    hDeath.dd = 1;\n  }\n  hDeath.yy = hyear;\n  return hDeath;\n}\n/**\n * Calculates a birthday or anniversary (non-yahrzeit).\n * `hyear` must be after original `date` of anniversary.\n * Returns `undefined` when requested year preceeds or is same as original year.\n *\n * Hebcal uses the algorithm defined in \"Calendrical Calculations\"\n * by Edward M. Reingold and Nachum Dershowitz.\n *\n * The birthday of someone born in Adar of an ordinary year or Adar II of\n * a leap year is also always in the last month of the year, be that Adar\n * or Adar II. The birthday in an ordinary year of someone born during the\n * first 29 days of Adar I in a leap year is on the corresponding day of Adar;\n * in a leap year, the birthday occurs in Adar I, as expected.\n *\n * Someone born on the thirtieth day of Marcheshvan, Kislev, or Adar I\n * has his birthday postponed until the first of the following month in\n * years where that day does not occur. [Calendrical Calculations p. 111]\n * @example\n * import {getBirthdayOrAnniversary} from '@hebcal/hdate';\n * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'\n * const anniversary = getBirthdayOrAnniversary(5780, dt); // '3/26/2020' == '1 Nisan 5780'\n * @param hyear Hebrew year\n * @param date Gregorian or Hebrew date of event\n * @returns anniversary occurring in `hyear`\n */\nfunction getBirthdayOrAnniversary(hyear, date) {\n  const hd = getBirthdayHD(hyear, date);\n  if (typeof hd === 'undefined') {\n    return hd;\n  }\n  return abs2greg(hebrew2abs(hd.yy, hd.mm, hd.dd));\n}\nfunction getBirthdayHD(hyear, date) {\n  const orig = toSimpleHebrewDate(date);\n  const origYear = orig.yy;\n  if (hyear === origYear) {\n    return orig;\n  } else if (hyear < origYear) {\n    // Hebrew year ${hyear} occurs on or before original date in ${origYear}\n    return undefined;\n  }\n  const isOrigLeap = isLeapYear(origYear);\n  let month = orig.mm;\n  let day = orig.dd;\n  if (month === ADAR_I && !isOrigLeap || month === ADAR_II && isOrigLeap) {\n    month = monthsInYear(hyear);\n  } else if (month === CHESHVAN && day === 30 && !longCheshvan(hyear)) {\n    month = KISLEV;\n    day = 1;\n  } else if (month === KISLEV && day === 30 && shortKislev(hyear)) {\n    month = TEVET;\n    day = 1;\n  } else if (month === ADAR_I && day === 30 && isOrigLeap && !isLeapYear(hyear)) {\n    month = NISAN;\n    day = 1;\n  }\n  return {\n    yy: hyear,\n    mm: month,\n    dd: day\n  };\n}\nexport { getBirthdayHD, getBirthdayOrAnniversary, getYahrzeit, getYahrzeitHD };","map":{"version":3,"names":["NISAN","months","CHESHVAN","KISLEV","TEVET","SHVAT","ADAR_I","ADAR_II","isSimpleHebrewDate","obj","yy","mm","dd","toSimpleHebrewDate","isDate","abs","greg2abs","abs2hebrew","getYahrzeit","hyear","date","hd","getYahrzeitHD","abs2greg","hebrew2abs","hDeath","undefined","longCheshvan","shortKislev","monthsInYear","isLeapYear","getBirthdayOrAnniversary","getBirthdayHD","orig","origYear","isOrigLeap","month","day"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/anniversary.ts"],"sourcesContent":["import {\n  hebrew2abs,\n  abs2hebrew,\n  isLeapYear,\n  months,\n  monthsInYear,\n  shortKislev,\n  longCheshvan,\n  SimpleHebrewDate,\n} from './hdateBase';\nimport {abs2greg, greg2abs, isDate} from './greg';\n\nconst NISAN = months.NISAN;\nconst CHESHVAN = months.CHESHVAN;\nconst KISLEV = months.KISLEV;\nconst TEVET = months.TEVET;\nconst SHVAT = months.SHVAT;\nconst ADAR_I = months.ADAR_I;\nconst ADAR_II = months.ADAR_II;\n\n/**\n * Returns true if the object is a SimpleHebrewDate\n * @private\n */\nfunction isSimpleHebrewDate(obj: any): boolean {\n  return (\n    typeof obj === 'object' &&\n    obj !== null &&\n    typeof obj.yy === 'number' &&\n    typeof obj.mm === 'number' &&\n    typeof obj.dd === 'number'\n  );\n}\n\nexport type AnniversaryDate = Date | SimpleHebrewDate | number;\n\n/**\n * @private\n */\nfunction toSimpleHebrewDate(obj: AnniversaryDate): SimpleHebrewDate {\n  if (isSimpleHebrewDate(obj)) {\n    return obj as SimpleHebrewDate;\n  } else if (isDate(obj)) {\n    const abs = greg2abs(obj as Date);\n    return abs2hebrew(abs);\n  } else {\n    // typeof obj === 'number'\n    return abs2hebrew(obj as number);\n  }\n}\n\n/**\n * Calculates yahrzeit.\n * `hyear` must be after original `date` of death.\n * Returns `undefined` when requested year preceeds or is same as original year.\n *\n * Hebcal uses the algorithm defined in \"Calendrical Calculations\"\n * by Edward M. Reingold and Nachum Dershowitz.\n *\n * The customary anniversary date of a death is more complicated and depends\n * also on the character of the year in which the first anniversary occurs.\n * There are several cases:\n *\n * * If the date of death is Marcheshvan 30, the anniversary in general depends\n *   on the first anniversary; if that first anniversary was not Marcheshvan 30,\n *   use the day before Kislev 1.\n * * If the date of death is Kislev 30, the anniversary in general again depends\n *   on the first anniversary — if that was not Kislev 30, use the day before\n *   Tevet 1.\n * * If the date of death is Adar II, the anniversary is the same day in the\n *   last month of the Hebrew year (Adar or Adar II).\n * * If the date of death is Adar I 30, the anniversary in a Hebrew year that\n *   is not a leap year (in which Adar only has 29 days) is the last day in\n *   Shevat.\n * * In all other cases, use the normal (that is, same month number) anniversary\n *   of the date of death. [Calendrical Calculations p. 113]\n * @example\n * import {getYahrzeit} from '@hebcal/hdate';\n * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'\n * const anniversary = getYahrzeit(5780, dt); // '2/25/2020' == '30 Sh\\'vat 5780'\n * @param hyear Hebrew year\n * @param date Gregorian or Hebrew date of death\n * @returns anniversary occurring in `hyear`\n */\nexport function getYahrzeit(\n  hyear: number,\n  date: AnniversaryDate\n): Date | undefined {\n  const hd = getYahrzeitHD(hyear, date);\n  if (typeof hd === 'undefined') {\n    return hd;\n  }\n  return abs2greg(hebrew2abs(hd.yy, hd.mm, hd.dd));\n}\n\nexport function getYahrzeitHD(\n  hyear: number,\n  date: AnniversaryDate\n): SimpleHebrewDate | undefined {\n  let hDeath = toSimpleHebrewDate(date);\n  if (hyear <= hDeath.yy) {\n    // Hebrew year ${hyear} occurs on or before original date in ${hDeath.yy}\n    return undefined;\n  }\n\n  if (\n    hDeath.mm === CHESHVAN &&\n    hDeath.dd === 30 &&\n    !longCheshvan(hDeath.yy + 1)\n  ) {\n    // If it's Heshvan 30 it depends on the first anniversary;\n    // if that was not Heshvan 30, use the day before Kislev 1.\n    hDeath = abs2hebrew(hebrew2abs(hyear, KISLEV, 1) - 1);\n  } else if (\n    hDeath.mm === KISLEV &&\n    hDeath.dd === 30 &&\n    shortKislev(hDeath.yy + 1)\n  ) {\n    // If it's Kislev 30 it depends on the first anniversary;\n    // if that was not Kislev 30, use the day before Teveth 1.\n    hDeath = abs2hebrew(hebrew2abs(hyear, TEVET, 1) - 1);\n  } else if (hDeath.mm === ADAR_II) {\n    // If it's Adar II, use the same day in last month of year (Adar or Adar II).\n    hDeath.mm = monthsInYear(hyear);\n  } else if (hDeath.mm === ADAR_I && hDeath.dd === 30 && !isLeapYear(hyear)) {\n    // If it's the 30th in Adar I and year is not a leap year\n    // (so Adar has only 29 days), use the last day in Shevat.\n    hDeath.dd = 30;\n    hDeath.mm = SHVAT;\n  }\n  // In all other cases, use the normal anniversary of the date of death.\n\n  // advance day to rosh chodesh if needed\n  if (hDeath.mm === CHESHVAN && hDeath.dd === 30 && !longCheshvan(hyear)) {\n    hDeath.mm = KISLEV;\n    hDeath.dd = 1;\n  } else if (hDeath.mm === KISLEV && hDeath.dd === 30 && shortKislev(hyear)) {\n    hDeath.mm = TEVET;\n    hDeath.dd = 1;\n  }\n\n  hDeath.yy = hyear;\n  return hDeath;\n}\n\n/**\n * Calculates a birthday or anniversary (non-yahrzeit).\n * `hyear` must be after original `date` of anniversary.\n * Returns `undefined` when requested year preceeds or is same as original year.\n *\n * Hebcal uses the algorithm defined in \"Calendrical Calculations\"\n * by Edward M. Reingold and Nachum Dershowitz.\n *\n * The birthday of someone born in Adar of an ordinary year or Adar II of\n * a leap year is also always in the last month of the year, be that Adar\n * or Adar II. The birthday in an ordinary year of someone born during the\n * first 29 days of Adar I in a leap year is on the corresponding day of Adar;\n * in a leap year, the birthday occurs in Adar I, as expected.\n *\n * Someone born on the thirtieth day of Marcheshvan, Kislev, or Adar I\n * has his birthday postponed until the first of the following month in\n * years where that day does not occur. [Calendrical Calculations p. 111]\n * @example\n * import {getBirthdayOrAnniversary} from '@hebcal/hdate';\n * const dt = new Date(2014, 2, 2); // '2014-03-02' == '30 Adar I 5774'\n * const anniversary = getBirthdayOrAnniversary(5780, dt); // '3/26/2020' == '1 Nisan 5780'\n * @param hyear Hebrew year\n * @param date Gregorian or Hebrew date of event\n * @returns anniversary occurring in `hyear`\n */\nexport function getBirthdayOrAnniversary(\n  hyear: number,\n  date: AnniversaryDate\n): Date | undefined {\n  const hd = getBirthdayHD(hyear, date);\n  if (typeof hd === 'undefined') {\n    return hd;\n  }\n  return abs2greg(hebrew2abs(hd.yy, hd.mm, hd.dd));\n}\n\nexport function getBirthdayHD(\n  hyear: number,\n  date: AnniversaryDate\n): SimpleHebrewDate | undefined {\n  const orig = toSimpleHebrewDate(date);\n  const origYear = orig.yy;\n  if (hyear === origYear) {\n    return orig;\n  } else if (hyear < origYear) {\n    // Hebrew year ${hyear} occurs on or before original date in ${origYear}\n    return undefined;\n  }\n  const isOrigLeap = isLeapYear(origYear);\n  let month = orig.mm;\n  let day = orig.dd;\n\n  if ((month === ADAR_I && !isOrigLeap) || (month === ADAR_II && isOrigLeap)) {\n    month = monthsInYear(hyear);\n  } else if (month === CHESHVAN && day === 30 && !longCheshvan(hyear)) {\n    month = KISLEV;\n    day = 1;\n  } else if (month === KISLEV && day === 30 && shortKislev(hyear)) {\n    month = TEVET;\n    day = 1;\n  } else if (\n    month === ADAR_I &&\n    day === 30 &&\n    isOrigLeap &&\n    !isLeapYear(hyear)\n  ) {\n    month = NISAN;\n    day = 1;\n  }\n\n  return {yy: hyear, mm: month, dd: day};\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}