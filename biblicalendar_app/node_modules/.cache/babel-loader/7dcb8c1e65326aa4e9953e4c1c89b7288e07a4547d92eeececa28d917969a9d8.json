{"ast":null,"code":"/*! @hebcal/core v5.9.0, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport { HDate, months } from '@hebcal/hdate';\nimport { renderParshaName } from './parshaName.js';\nimport QuickLRU from 'quick-lru';\nimport './locale.js';\n\n/*\n    Hebcal - A Jewish Calendar Generator\n    Copyright (c) 1994-2020 Danny Sadinoff\n    Portions copyright Eyal Schachter and Michael J. Radwin\n\n    https://github.com/hebcal/hebcal-es6\n\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License\n    as published by the Free Software Foundation; either version 2\n    of the License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n/*\n * Many of the following algorithms were taken from hebrew calendar\n * routines by Maimonedes, from his Mishneh Torah, and implemented by\n *  Nachum Dershowitz                Department of Computer Science\n *  (217) 333-4219                   University of Illinois at Urbana-Champaign\n *  nachum@cs.uiuedu               1304 West Springfield Avenue\n *                                   Urbana, Illinois 61801\n *\n * The routines were included in the emacs 19 distribution.\n *\n */\nconst INCOMPLETE = 0;\nconst REGULAR = 1;\nconst COMPLETE = 2;\nfunction yearType(hyear) {\n  const longC = HDate.longCheshvan(hyear);\n  const shortK = HDate.shortKislev(hyear);\n  if (longC && !shortK) {\n    return COMPLETE;\n  } else if (!longC && shortK) {\n    return INCOMPLETE;\n  } else {\n    return REGULAR;\n  }\n}\n/**\n * Represents Parashah HaShavua for an entire Hebrew year\n */\nclass Sedra {\n  /**\n   * Caculates the Parashah HaShavua for an entire Hebrew year\n   * @param hyear - Hebrew year (e.g. 5749)\n   * @param il - Use Israel sedra schedule (false for Diaspora)\n   */\n  constructor(hyear, il) {\n    hyear = +hyear;\n    this.year = hyear;\n    const rh0 = new HDate(1, months.TISHREI, hyear);\n    const rh = rh0.abs();\n    const rhDay = rh0.getDay() + 1;\n    // find the first Saturday on or after Rosh Hashana\n    this.firstSaturday = HDate.dayOnOrBefore(6, rh + 6);\n    const leap = +HDate.isLeapYear(hyear);\n    this.il = Boolean(il);\n    const type = yearType(hyear);\n    let key = `${leap}${rhDay}${type}`;\n    if (types[key]) {\n      this.theSedraArray = types[key];\n    } else {\n      key = key + +this.il; // cast to num, then concat\n      this.theSedraArray = types[key];\n    }\n    if (!this.theSedraArray) {\n      throw new Error(`improper sedra year type ${key} calculated for ${hyear}`);\n    }\n  }\n  /**\n   * Returns the parsha (or parshiyot) read on Hebrew date\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   */\n  get(hd) {\n    return this.lookup(hd).parsha;\n  }\n  /**\n   * Looks up parsha for the date, then returns a translated or transliterated string\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale\n   */\n  getString(hd, locale) {\n    const parsha = this.get(hd);\n    return renderParshaName(parsha, locale);\n  }\n  /**\n   * Checks to see if this day would be a regular parasha HaShavua\n   * Torah reading or special holiday reading\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   */\n  isParsha(hd) {\n    return !this.lookup(hd).chag;\n  }\n  /**\n   * Returns the date that a parsha occurs\n   * or `null` if the parsha doesn't occur this year\n   * @param parsha if a `string`, specified with Sephardic transliterations\n   *  like `'Noach'` or `'Matot-Masei'`. If an array, must be a 1- or 2-element\n   *  array such as `['Noach']` or `['Matot', 'Masei']`. If a `number`, should\n   *  be a 0-based parsha index (`0` for Bereshit, `1` for Noach) or a negative\n   *  number for a doubled parsha (e.g. `-21` for Vayakhel-Pekudei)\n   */\n  find(parsha) {\n    if (typeof parsha === 'number') {\n      if (parsha >= parshiot.length || parsha < 0 && !isValidDouble(parsha)) {\n        throw new RangeError(`Invalid parsha number: ${parsha}`);\n      }\n      return this.findInternal(parsha);\n    } else if (typeof parsha === 'string') {\n      const num = parsha2id.get(parsha);\n      if (typeof num === 'number') {\n        return this.find(num);\n      } else if (parsha.indexOf('-') !== -1) {\n        if (parsha === CHMPESACH || parsha === CHMSUKOT) {\n          return this.findInternal(parsha);\n        }\n        return this.find(parsha.split('-'));\n      } else {\n        // try to find Saturday holiday like 'Yom Kippur'\n        return this.findInternal(parsha);\n      }\n    } else if (Array.isArray(parsha)) {\n      const plen = parsha.length;\n      if (plen !== 1 && plen !== 2 || typeof parsha[0] !== 'string') {\n        throw new TypeError(`Invalid parsha argument: ${JSON.stringify(parsha)}`);\n      }\n      if (plen === 1) {\n        return this.find(parsha[0]);\n      }\n      const p1 = parsha[0];\n      const p2 = parsha[1];\n      const num1 = parsha2id.get(p1);\n      const num2 = parsha2id.get(p2);\n      if (typeof num1 !== 'number' || typeof num2 !== 'number' || num2 !== num1 + 1 || !isValidDouble(-num1)) {\n        throw new RangeError(`Unrecognized parsha name: ${p1}-${p2}`);\n      }\n      return this.find(-num1);\n    }\n    return null; /* NOTREACHED */\n  }\n  findInternal(parsha) {\n    const idx = this.theSedraArray.indexOf(parsha);\n    if (idx === -1) {\n      return null; // doesn't occur this year\n    }\n    return new HDate(this.firstSaturday + idx * 7);\n  }\n  /**\n   * Returns the date that a parsha (or its doubled or undoubled counterpart)\n   * occurs, or `null` if the parsha doesn't occur this year\n   */\n  findContaining(parsha) {\n    const hdate = this.find(parsha);\n    if (hdate) {\n      return hdate;\n    }\n    if (typeof parsha === 'number') {\n      // a valid negative number (double parsha in a year where they are\n      // combined) would've been found above, and a invalid negative number\n      // would've thrown an error, so this parsha must be a positive number\n      // representing either p1 or p2\n      const p1 = -parsha;\n      if (isValidDouble(p1)) {\n        return this.find(p1);\n      } else {\n        // this must be the second individual parsha of a doubled pair\n        // for example 29 for Kedoshim, so check for -28 for Achrei Mot-Kedoshim\n        return this.find(p1 + 1);\n      }\n    } else {\n      const num = parsha2id.get(parsha);\n      if (num) {\n        // parsha is either the first or second individual parsha of\n        // a pair that is doubled this year\n        const p1 = -num;\n        if (isValidDouble(p1)) {\n          return this.find(p1);\n        } else {\n          return this.find(p1 + 1);\n        }\n      } else {\n        // this was indeed a doubled parsha, so return date of the first half\n        const [p1] = parsha.split('-');\n        return this.find(p1);\n      }\n    }\n  }\n  /**\n   * Returns the underlying annual sedra schedule.\n   * Used by `@hebcal/triennial`\n   */\n  getSedraArray() {\n    return this.theSedraArray;\n  }\n  /**\n   * R.D. date of the first Saturday on or after Rosh Hashana\n   */\n  getFirstSaturday() {\n    return this.firstSaturday;\n  }\n  getYear() {\n    return this.year;\n  }\n  /**\n   * Returns an object describing the parsha on the first Saturday on or after `hd`\n   * @param hd Hebrew date or R.D. days\n   */\n  lookup(hd) {\n    const abs = typeof hd === 'number' ? hd : HDate.isHDate(hd) ? hd.abs() : NaN;\n    if (isNaN(abs)) {\n      throw new TypeError(`Bad date argument: ${hd}`);\n    }\n    // find the first saturday on or after today's date\n    const saturday = HDate.dayOnOrBefore(6, abs + 6);\n    const weekNum = (saturday - this.firstSaturday) / 7;\n    const index = this.theSedraArray[weekNum];\n    if (typeof index === 'undefined') {\n      const sedra = getSedra(this.year + 1, this.il);\n      return sedra.lookup(saturday); // must be next year\n    }\n    const hdate = new HDate(saturday);\n    if (typeof index === 'string') {\n      // Shabbat has a chag. Return a description\n      return {\n        parsha: [index],\n        chag: true,\n        hdate\n      };\n    }\n    if (index >= 0) {\n      return {\n        parsha: [parshiot[index]],\n        chag: false,\n        num: index + 1,\n        hdate\n      };\n    }\n    const p1 = D(index); // undouble the parsha\n    return {\n      parsha: [parshiot[p1], parshiot[p1 + 1]],\n      chag: false,\n      num: [p1 + 1, p1 + 2],\n      hdate\n    };\n  }\n}\n/**\n * The 54 parshiyot of the Torah as transilterated strings.\n * parshiot[0] == 'Bereshit', parshiot[1] == 'Noach', parshiot[52] == \"Ha'azinu\".\n * @readonly\n * @type {string[]}\n */\nconst parshiot = ['Bereshit', 'Noach', 'Lech-Lecha', 'Vayera', 'Chayei Sara', 'Toldot', 'Vayetzei', 'Vayishlach', 'Vayeshev', 'Miketz', 'Vayigash', 'Vayechi', 'Shemot', 'Vaera', 'Bo', 'Beshalach', 'Yitro', 'Mishpatim', 'Terumah', 'Tetzaveh', 'Ki Tisa', 'Vayakhel', 'Pekudei', 'Vayikra', 'Tzav', 'Shmini', 'Tazria', 'Metzora', 'Achrei Mot', 'Kedoshim', 'Emor', 'Behar', 'Bechukotai', 'Bamidbar', 'Nasso', \"Beha'alotcha\", \"Sh'lach\", 'Korach', 'Chukat', 'Balak', 'Pinchas', 'Matot', 'Masei', 'Devarim', 'Vaetchanan', 'Eikev', \"Re'eh\", 'Shoftim', 'Ki Teitzei', 'Ki Tavo', 'Nitzavim', 'Vayeilech', \"Ha'azinu\"];\n// 0-based parsha IDs\nconst parsha2id = new Map();\nfor (let id = 0; id < parshiot.length; id++) {\n  const name = parshiot[id];\n  parsha2id.set(name, id);\n}\n// 0-based parsha IDs\nconst doubles = [21,\n// Vayakhel-Pekudei\n26,\n// Tazria-Metzora\n28,\n// Achrei Mot-Kedoshim\n31,\n// Behar-Bechukotai\n38,\n// Chukat-Balak\n41,\n// Matot-Masei\n50 // Nitzavim-Vayeilech\n];\n/**\n * @private\n * @param id a negative number\n */\nfunction isValidDouble(id) {\n  return doubles.includes(-id);\n}\n/**\n * parsha doubler/undoubler\n * @private\n * @param p\n */\nfunction D(p) {\n  return -p;\n}\nconst RH = 'Rosh Hashana'; // 0\nconst YK = 'Yom Kippur'; // 1\nconst SUKKOT = 'Sukkot'; // 0\nconst CHMSUKOT = 'Sukkot Shabbat Chol ha-Moed'; // 0\nconst SHMINI = 'Shmini Atzeret'; // 0\nconst PESACH = 'Pesach'; // 25\nconst PESACH1 = 'Pesach I';\nconst CHMPESACH = 'Pesach Shabbat Chol ha-Moed'; // 25\nconst PESACH7 = 'Pesach VII'; // 25\nconst PESACH8 = 'Pesach VIII';\nconst SHAVUOT = 'Shavuot'; // 33\n/**\n * Returns an array from start to end\n * @private\n * @param start beginning number, inclusive\n * @param stop ending number, inclusive\n */\nfunction range(start, stop) {\n  return Array.from({\n    length: stop - start + 1\n  }, (v, k) => k + start);\n}\nconst yearStartVayeilech = [51, 52, CHMSUKOT];\nconst yearStartHaazinu = [52, YK, CHMSUKOT];\nconst yearStartRH = [RH, 52, SUKKOT, SHMINI];\nconst r020 = range(0, 20);\nconst r027 = range(0, 27);\nconst r3340 = range(33, 40);\nconst r4349 = range(43, 49);\nconst r4350 = range(43, 50);\n/**\n * The ordinary year types (keviot)\n * names are leap/nonleap - day - incomplete/regular/complete - diaspora/Israel\n * @private\n * @readonly\n */\nconst types = {\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Tuesday. */\n  // e.g. 5753\n  '020': yearStartVayeilech.concat(r020, D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), r3340, D(41), r4349, D(50)),\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Thursday. */\n  // e.g. 5756\n  '0220': yearStartVayeilech.concat(r020, D(21), 23, 24, PESACH, 25, D(26), D(28), 30, D(31), 33, SHAVUOT, range(34, 37), D(38), 40, D(41), r4349, D(50)),\n  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29\n   * days and Kislev has 30 days), and has Passover start on Saturday. */\n  // e.g. 5701\n  '0510': yearStartHaazinu.concat(r020, D(21), 23, 24, PESACH1, PESACH8, 25, D(26), D(28), 30, D(31), r3340, D(41), r4350),\n  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29\n   * days and Kislev has 30 days), and has Passover start on Saturday. */\n  // e.g. 5745\n  '0511': yearStartHaazinu.concat(r020, D(21), 23, 24, PESACH, 25, D(26), D(28), range(30, 40), D(41), r4350),\n  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Sunday. */\n  // e.g. 5754\n  '052': yearStartHaazinu.concat(range(0, 24), PESACH7, 25, D(26), D(28), 30, D(31), r3340, D(41), r4350),\n  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and Kislev\n   * each have 29 days), and has Passover start on Sunday. */\n  // e.g. 5761\n  '070': yearStartRH.concat(r020, D(21), 23, 24, PESACH7, 25, D(26), D(28), 30, D(31), r3340, D(41), r4350),\n  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Tuesday. */\n  // e.g. 5716\n  '072': yearStartRH.concat(r020, D(21), 23, 24, CHMPESACH, 25, D(26), D(28), 30, D(31), r3340, D(41), r4349, D(50)),\n  /* --  The leap year types (keviot) -- */\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Thursday. */\n  // e.g. 5746\n  '1200': yearStartVayeilech.concat(r027, CHMPESACH, range(28, 33), SHAVUOT, range(34, 37), D(38), 40, D(41), r4349, D(50)),\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Thursday. */\n  // e.g. 5746\n  '1201': yearStartVayeilech.concat(r027, CHMPESACH, range(28, 40), D(41), r4349, D(50)),\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Saturday. */\n  // e.g.5752\n  '1220': yearStartVayeilech.concat(r027, PESACH1, PESACH8, range(28, 40), D(41), r4350),\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Saturday. */\n  // e.g.5752\n  '1221': yearStartVayeilech.concat(r027, PESACH, range(28, 50)),\n  /* Hebrew year that starts on Thursday, is `incomplete' (Heshvan and\n   * Kislev both have 29 days), and has Passover start on Sunday. */\n  // e.g. 5768\n  '150': yearStartHaazinu.concat(range(0, 28), PESACH7, range(29, 50)),\n  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and\n   * Kislev both have 30 days), and has Passover start on Tuesday. */\n  // eg. 5771\n  '152': yearStartHaazinu.concat(range(0, 28), CHMPESACH, range(29, 49), D(50)),\n  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Tuesday. */\n  // e.g.5757\n  '170': yearStartRH.concat(r027, CHMPESACH, range(28, 40), D(41), r4349, D(50)),\n  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Thursday. */\n  '1720': yearStartRH.concat(r027, CHMPESACH, range(28, 33), SHAVUOT, range(34, 37), D(38), 40, D(41), r4349, D(50))\n};\n/* Hebrew year that starts on Monday, is `complete' (Heshvan and\n * Kislev each have 30 days), and has Passover start on Thursday. */\ntypes['0221'] = types['020'];\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Thursday. */\n// e.g. 5715\ntypes['0310'] = types['0220'];\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Thursday. */\ntypes['0311'] = types['020'];\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Saturday. */\n// e.g. 5715\ntypes['1310'] = types['1220'];\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Saturday. */\ntypes['1311'] = types['1221'];\n/* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n * Kislev each have 30 days), and has Passover start on Thursday. */\ntypes['1721'] = types['170'];\nconst sedraCache = new QuickLRU({\n  maxSize: 400\n});\n/**\n * Convenience function to create an instance of `Sedra` or reuse a previously\n * created and cached instance.\n * @param hyear\n * @param il\n */\nfunction getSedra(hyear, il) {\n  const cacheKey = `${hyear}-${il ? 1 : 0}`;\n  let sedra = sedraCache.get(cacheKey);\n  if (!sedra) {\n    sedra = new Sedra(hyear, il);\n    sedraCache.set(cacheKey, sedra);\n  }\n  return sedra;\n}\nexport { Sedra, getSedra, parshiot };","map":{"version":3,"names":["INCOMPLETE","REGULAR","COMPLETE","yearType","hyear","longC","HDate","longCheshvan","shortK","shortKislev","Sedra","constructor","il","year","rh0","months","TISHREI","rh","abs","rhDay","getDay","firstSaturday","dayOnOrBefore","leap","isLeapYear","Boolean","type","key","types","theSedraArray","Error","get","hd","lookup","parsha","getString","locale","renderParshaName","isParsha","chag","find","parshiot","length","isValidDouble","RangeError","findInternal","num","parsha2id","indexOf","CHMPESACH","CHMSUKOT","split","Array","isArray","plen","TypeError","JSON","stringify","p1","p2","num1","num2","idx","findContaining","hdate","getSedraArray","getFirstSaturday","getYear","isHDate","NaN","isNaN","saturday","weekNum","index","sedra","getSedra","D","Map","id","name","set","doubles","includes","p","RH","YK","SUKKOT","SHMINI","PESACH","PESACH1","PESACH7","PESACH8","SHAVUOT","range","start","stop","from","v","k","yearStartVayeilech","yearStartHaazinu","yearStartRH","r020","r027","r3340","r4349","r4350","concat","sedraCache","QuickLRU","maxSize","cacheKey"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/sedra.ts"],"sourcesContent":["/*\n    Hebcal - A Jewish Calendar Generator\n    Copyright (c) 1994-2020 Danny Sadinoff\n    Portions copyright Eyal Schachter and Michael J. Radwin\n\n    https://github.com/hebcal/hebcal-es6\n\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License\n    as published by the Free Software Foundation; either version 2\n    of the License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Many of the following algorithms were taken from hebrew calendar\n * routines by Maimonedes, from his Mishneh Torah, and implemented by\n *  Nachum Dershowitz                Department of Computer Science\n *  (217) 333-4219                   University of Illinois at Urbana-Champaign\n *  nachum@cs.uiuedu               1304 West Springfield Avenue\n *                                   Urbana, Illinois 61801\n *\n * The routines were included in the emacs 19 distribution.\n *\n */\nimport {HDate, months} from '@hebcal/hdate';\nimport {renderParshaName} from './parshaName';\nimport QuickLRU from 'quick-lru';\nimport './locale'; // Adds Hebrew and Ashkenazic translations\n\nconst INCOMPLETE = 0;\nconst REGULAR = 1;\nconst COMPLETE = 2;\n\nfunction yearType(hyear: number): number {\n  const longC = HDate.longCheshvan(hyear);\n  const shortK = HDate.shortKislev(hyear);\n  if (longC && !shortK) {\n    return COMPLETE;\n  } else if (!longC && shortK) {\n    return INCOMPLETE;\n  } else {\n    return REGULAR;\n  }\n}\n\n/** The result from `Sedra.lookup()` */\nexport type SedraResult = {\n  /**\n   * Name of the parsha (or parshiyot) read on\n   * Hebrew date, e.g. `['Noach']` or `['Matot', 'Masei']`\n   */\n  parsha: string[];\n  /**\n   * True if this is a regular parasha HaShavua\n   * Torah reading, false if it's a special holiday reading\n   */\n  chag: boolean;\n  /**\n   * The parsha number (or numbers) using 1-indexing.\n   * A `number` for a regular (single) parsha, and a `number[]`\n   * for a doubled parsha.\n   * For Parashat *Bereshit*, `num` would be equal to `1`, and for\n   * *Matot-Masei* it would be `[42, 43]`\n   */\n  num?: number | number[];\n  /** The date of the Shabbat this parsha is read */\n  hdate: HDate;\n};\n\n/**\n * Represents Parashah HaShavua for an entire Hebrew year\n */\nexport class Sedra {\n  private readonly year: number;\n  private readonly il: boolean;\n  private readonly firstSaturday: number;\n  private readonly theSedraArray: readonly NumberOrString[];\n  /**\n   * Caculates the Parashah HaShavua for an entire Hebrew year\n   * @param hyear - Hebrew year (e.g. 5749)\n   * @param il - Use Israel sedra schedule (false for Diaspora)\n   */\n  constructor(hyear: number, il: boolean) {\n    hyear = +hyear;\n    this.year = hyear;\n\n    const rh0 = new HDate(1, months.TISHREI, hyear);\n    const rh = rh0.abs();\n    const rhDay = rh0.getDay() + 1;\n\n    // find the first Saturday on or after Rosh Hashana\n    this.firstSaturday = HDate.dayOnOrBefore(6, rh + 6);\n    const leap = +HDate.isLeapYear(hyear);\n    this.il = Boolean(il);\n\n    const type = yearType(hyear);\n    let key = `${leap}${rhDay}${type}`;\n    if (types[key]) {\n      this.theSedraArray = types[key];\n    } else {\n      key = key + +this.il; // cast to num, then concat\n      this.theSedraArray = types[key];\n    }\n\n    if (!this.theSedraArray) {\n      throw new Error(\n        `improper sedra year type ${key} calculated for ${hyear}`\n      );\n    }\n  }\n\n  /**\n   * Returns the parsha (or parshiyot) read on Hebrew date\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   */\n  get(hd: HDate | number): string[] {\n    return this.lookup(hd).parsha;\n  }\n\n  /**\n   * Looks up parsha for the date, then returns a translated or transliterated string\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   * @param [locale] Optional locale name (i.e: `'he'`, `'fr'`). Defaults to active locale\n   */\n  getString(hd: HDate | number, locale?: string): string {\n    const parsha = this.get(hd);\n    return renderParshaName(parsha, locale);\n  }\n\n  /**\n   * Checks to see if this day would be a regular parasha HaShavua\n   * Torah reading or special holiday reading\n   * @deprecated Use {@link lookup} instead\n   * @param hd Hebrew date or R.D. days\n   */\n  isParsha(hd: HDate | number): boolean {\n    return !this.lookup(hd).chag;\n  }\n\n  /**\n   * Returns the date that a parsha occurs\n   * or `null` if the parsha doesn't occur this year\n   * @param parsha if a `string`, specified with Sephardic transliterations\n   *  like `'Noach'` or `'Matot-Masei'`. If an array, must be a 1- or 2-element\n   *  array such as `['Noach']` or `['Matot', 'Masei']`. If a `number`, should\n   *  be a 0-based parsha index (`0` for Bereshit, `1` for Noach) or a negative\n   *  number for a doubled parsha (e.g. `-21` for Vayakhel-Pekudei)\n   */\n  find(parsha: number | string | string[]): HDate | null {\n    if (typeof parsha === 'number') {\n      if (parsha >= parshiot.length || (parsha < 0 && !isValidDouble(parsha))) {\n        throw new RangeError(`Invalid parsha number: ${parsha}`);\n      }\n      return this.findInternal(parsha);\n    } else if (typeof parsha === 'string') {\n      const num = parsha2id.get(parsha);\n      if (typeof num === 'number') {\n        return this.find(num);\n      } else if (parsha.indexOf('-') !== -1) {\n        if (parsha === CHMPESACH || parsha === CHMSUKOT) {\n          return this.findInternal(parsha);\n        }\n        return this.find(parsha.split('-'));\n      } else {\n        // try to find Saturday holiday like 'Yom Kippur'\n        return this.findInternal(parsha);\n      }\n    } else if (Array.isArray(parsha)) {\n      const plen = parsha.length;\n      if ((plen !== 1 && plen !== 2) || typeof parsha[0] !== 'string') {\n        throw new TypeError(\n          `Invalid parsha argument: ${JSON.stringify(parsha)}`\n        );\n      }\n      if (plen === 1) {\n        return this.find(parsha[0]);\n      }\n      const p1 = parsha[0];\n      const p2 = parsha[1];\n      const num1 = parsha2id.get(p1);\n      const num2 = parsha2id.get(p2);\n      if (\n        typeof num1 !== 'number' ||\n        typeof num2 !== 'number' ||\n        num2 !== num1 + 1 ||\n        !isValidDouble(-num1)\n      ) {\n        throw new RangeError(`Unrecognized parsha name: ${p1}-${p2}`);\n      }\n      return this.find(-num1);\n    }\n    return null; /* NOTREACHED */\n  }\n\n  private findInternal(parsha: NumberOrString): HDate | null {\n    const idx = this.theSedraArray.indexOf(parsha);\n    if (idx === -1) {\n      return null; // doesn't occur this year\n    }\n    return new HDate(this.firstSaturday + idx * 7);\n  }\n\n  /**\n   * Returns the date that a parsha (or its doubled or undoubled counterpart)\n   * occurs, or `null` if the parsha doesn't occur this year\n   */\n  findContaining(parsha: number | string): HDate | null {\n    const hdate = this.find(parsha);\n    if (hdate) {\n      return hdate;\n    }\n    if (typeof parsha === 'number') {\n      // a valid negative number (double parsha in a year where they are\n      // combined) would've been found above, and a invalid negative number\n      // would've thrown an error, so this parsha must be a positive number\n      // representing either p1 or p2\n      const p1 = -parsha;\n      if (isValidDouble(p1)) {\n        return this.find(p1);\n      } else {\n        // this must be the second individual parsha of a doubled pair\n        // for example 29 for Kedoshim, so check for -28 for Achrei Mot-Kedoshim\n        return this.find(p1 + 1);\n      }\n    } else {\n      const num = parsha2id.get(parsha);\n      if (num) {\n        // parsha is either the first or second individual parsha of\n        // a pair that is doubled this year\n        const p1 = -num;\n        if (isValidDouble(p1)) {\n          return this.find(p1);\n        } else {\n          return this.find(p1 + 1);\n        }\n      } else {\n        // this was indeed a doubled parsha, so return date of the first half\n        const [p1] = parsha.split('-');\n        return this.find(p1);\n      }\n    }\n  }\n\n  /**\n   * Returns the underlying annual sedra schedule.\n   * Used by `@hebcal/triennial`\n   */\n  getSedraArray(): readonly NumberOrString[] {\n    return this.theSedraArray;\n  }\n\n  /**\n   * R.D. date of the first Saturday on or after Rosh Hashana\n   */\n  getFirstSaturday(): number {\n    return this.firstSaturday;\n  }\n\n  getYear(): number {\n    return this.year;\n  }\n\n  /**\n   * Returns an object describing the parsha on the first Saturday on or after `hd`\n   * @param hd Hebrew date or R.D. days\n   */\n  lookup(hd: HDate | number): SedraResult {\n    const abs =\n      typeof hd === 'number' ? hd : HDate.isHDate(hd) ? hd.abs() : NaN;\n\n    if (isNaN(abs)) {\n      throw new TypeError(`Bad date argument: ${hd}`);\n    }\n\n    // find the first saturday on or after today's date\n    const saturday = HDate.dayOnOrBefore(6, abs + 6);\n\n    const weekNum = (saturday - this.firstSaturday) / 7;\n    const index = this.theSedraArray[weekNum];\n\n    if (typeof index === 'undefined') {\n      const sedra = getSedra(this.year + 1, this.il);\n      return sedra.lookup(saturday); // must be next year\n    }\n    const hdate = new HDate(saturday);\n    if (typeof index === 'string') {\n      // Shabbat has a chag. Return a description\n      return {parsha: [index], chag: true, hdate};\n    }\n    if (index >= 0) {\n      return {parsha: [parshiot[index]], chag: false, num: index + 1, hdate};\n    }\n\n    const p1 = D(index); // undouble the parsha\n    return {\n      parsha: [parshiot[p1], parshiot[p1 + 1]],\n      chag: false,\n      num: [p1 + 1, p1 + 2],\n      hdate,\n    };\n  }\n}\n\n/**\n * The 54 parshiyot of the Torah as transilterated strings.\n * parshiot[0] == 'Bereshit', parshiot[1] == 'Noach', parshiot[52] == \"Ha'azinu\".\n * @readonly\n * @type {string[]}\n */\nexport const parshiot: readonly string[] = [\n  'Bereshit',\n  'Noach',\n  'Lech-Lecha',\n  'Vayera',\n  'Chayei Sara',\n  'Toldot',\n  'Vayetzei',\n  'Vayishlach',\n  'Vayeshev',\n  'Miketz',\n  'Vayigash',\n  'Vayechi',\n  'Shemot',\n  'Vaera',\n  'Bo',\n  'Beshalach',\n  'Yitro',\n  'Mishpatim',\n  'Terumah',\n  'Tetzaveh',\n  'Ki Tisa',\n  'Vayakhel',\n  'Pekudei',\n  'Vayikra',\n  'Tzav',\n  'Shmini',\n  'Tazria',\n  'Metzora',\n  'Achrei Mot',\n  'Kedoshim',\n  'Emor',\n  'Behar',\n  'Bechukotai',\n  'Bamidbar',\n  'Nasso',\n  \"Beha'alotcha\",\n  \"Sh'lach\",\n  'Korach',\n  'Chukat',\n  'Balak',\n  'Pinchas',\n  'Matot',\n  'Masei',\n  'Devarim',\n  'Vaetchanan',\n  'Eikev',\n  \"Re'eh\",\n  'Shoftim',\n  'Ki Teitzei',\n  'Ki Tavo',\n  'Nitzavim',\n  'Vayeilech',\n  \"Ha'azinu\",\n] as const;\n\n// 0-based parsha IDs\nconst parsha2id = new Map<string, number>();\nfor (let id = 0; id < parshiot.length; id++) {\n  const name = parshiot[id];\n  parsha2id.set(name, id);\n}\n\n// 0-based parsha IDs\nconst doubles = [\n  21, // Vayakhel-Pekudei\n  26, // Tazria-Metzora\n  28, // Achrei Mot-Kedoshim\n  31, // Behar-Bechukotai\n  38, // Chukat-Balak\n  41, // Matot-Masei\n  50, // Nitzavim-Vayeilech\n];\n\n/**\n * @private\n * @param id a negative number\n */\nfunction isValidDouble(id: number): boolean {\n  return doubles.includes(-id);\n}\n\n/**\n * parsha doubler/undoubler\n * @private\n * @param p\n */\nfunction D(p: number): number {\n  return -p;\n}\n\nconst RH = 'Rosh Hashana'; // 0\nconst YK = 'Yom Kippur'; // 1\n\nconst SUKKOT = 'Sukkot'; // 0\nconst CHMSUKOT = 'Sukkot Shabbat Chol ha-Moed'; // 0\nconst SHMINI = 'Shmini Atzeret'; // 0\n\nconst PESACH = 'Pesach'; // 25\nconst PESACH1 = 'Pesach I';\nconst CHMPESACH = 'Pesach Shabbat Chol ha-Moed'; // 25\nconst PESACH7 = 'Pesach VII'; // 25\nconst PESACH8 = 'Pesach VIII';\nconst SHAVUOT = 'Shavuot'; // 33\n\n/**\n * Returns an array from start to end\n * @private\n * @param start beginning number, inclusive\n * @param stop ending number, inclusive\n */\nfunction range(start: number, stop: number): readonly number[] {\n  return Array.from({length: stop - start + 1}, (v, k) => k + start);\n}\n\ntype NumberOrString = number | string;\n\nconst yearStartVayeilech: readonly NumberOrString[] = [51, 52, CHMSUKOT];\nconst yearStartHaazinu: readonly NumberOrString[] = [52, YK, CHMSUKOT];\nconst yearStartRH: readonly NumberOrString[] = [RH, 52, SUKKOT, SHMINI];\nconst r020 = range(0, 20);\nconst r027 = range(0, 27);\nconst r3340 = range(33, 40);\nconst r4349 = range(43, 49);\nconst r4350 = range(43, 50);\n\n/**\n * The ordinary year types (keviot)\n * names are leap/nonleap - day - incomplete/regular/complete - diaspora/Israel\n * @private\n * @readonly\n */\nconst types: Record<string, readonly NumberOrString[]> = {\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Tuesday. */\n  // e.g. 5753\n  '020': yearStartVayeilech.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    PESACH,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    r3340,\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Thursday. */\n  // e.g. 5756\n  '0220': yearStartVayeilech.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    PESACH,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    33,\n    SHAVUOT,\n    range(34, 37),\n    D(38),\n    40,\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29\n   * days and Kislev has 30 days), and has Passover start on Saturday. */\n  // e.g. 5701\n  '0510': yearStartHaazinu.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    PESACH1,\n    PESACH8,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    r3340,\n    D(41),\n    r4350\n  ),\n\n  /* Hebrew year that starts on Thursday, is `regular' (Heshvan has 29\n   * days and Kislev has 30 days), and has Passover start on Saturday. */\n  // e.g. 5745\n  '0511': yearStartHaazinu.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    PESACH,\n    25,\n    D(26),\n    D(28),\n    range(30, 40),\n    D(41),\n    r4350\n  ),\n\n  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Sunday. */\n  // e.g. 5754\n  '052': yearStartHaazinu.concat(\n    range(0, 24),\n    PESACH7,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    r3340,\n    D(41),\n    r4350\n  ),\n\n  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and Kislev\n   * each have 29 days), and has Passover start on Sunday. */\n  // e.g. 5761\n  '070': yearStartRH.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    PESACH7,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    r3340,\n    D(41),\n    r4350\n  ),\n\n  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Tuesday. */\n  // e.g. 5716\n  '072': yearStartRH.concat(\n    r020,\n    D(21),\n    23,\n    24,\n    CHMPESACH,\n    25,\n    D(26),\n    D(28),\n    30,\n    D(31),\n    r3340,\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* --  The leap year types (keviot) -- */\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Thursday. */\n  // e.g. 5746\n  '1200': yearStartVayeilech.concat(\n    r027,\n    CHMPESACH,\n    range(28, 33),\n    SHAVUOT,\n    range(34, 37),\n    D(38),\n    40,\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* Hebrew year that starts on Monday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Thursday. */\n  // e.g. 5746\n  '1201': yearStartVayeilech.concat(\n    r027,\n    CHMPESACH,\n    range(28, 40),\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Saturday. */\n  // e.g.5752\n  '1220': yearStartVayeilech.concat(\n    r027,\n    PESACH1,\n    PESACH8,\n    range(28, 40),\n    D(41),\n    r4350\n  ),\n\n  /* Hebrew year that starts on Monday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Saturday. */\n  // e.g.5752\n  '1221': yearStartVayeilech.concat(r027, PESACH, range(28, 50)),\n\n  /* Hebrew year that starts on Thursday, is `incomplete' (Heshvan and\n   * Kislev both have 29 days), and has Passover start on Sunday. */\n  // e.g. 5768\n  '150': yearStartHaazinu.concat(range(0, 28), PESACH7, range(29, 50)),\n\n  /* Hebrew year that starts on Thursday, is `complete' (Heshvan and\n   * Kislev both have 30 days), and has Passover start on Tuesday. */\n  // eg. 5771\n  '152': yearStartHaazinu.concat(range(0, 28), CHMPESACH, range(29, 49), D(50)),\n\n  /* Hebrew year that starts on Saturday, is `incomplete' (Heshvan and\n   * Kislev each have 29 days), and has Passover start on Tuesday. */\n  // e.g.5757\n  '170': yearStartRH.concat(\n    r027,\n    CHMPESACH,\n    range(28, 40),\n    D(41),\n    r4349,\n    D(50)\n  ),\n\n  /* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n   * Kislev each have 30 days), and has Passover start on Thursday. */\n  '1720': yearStartRH.concat(\n    r027,\n    CHMPESACH,\n    range(28, 33),\n    SHAVUOT,\n    range(34, 37),\n    D(38),\n    40,\n    D(41),\n    r4349,\n    D(50)\n  ),\n} as const;\n\n/* Hebrew year that starts on Monday, is `complete' (Heshvan and\n * Kislev each have 30 days), and has Passover start on Thursday. */\ntypes['0221'] = types['020'];\n\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Thursday. */\n// e.g. 5715\ntypes['0310'] = types['0220'];\n\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Thursday. */\ntypes['0311'] = types['020'];\n\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Saturday. */\n// e.g. 5715\ntypes['1310'] = types['1220'];\n/* Hebrew year that starts on Tuesday, is `regular' (Heshvan has 29\n * days and Kislev has 30 days), and has Passover start on Saturday. */\ntypes['1311'] = types['1221'];\n\n/* Hebrew year that starts on Saturday, is `complete' (Heshvan and\n * Kislev each have 30 days), and has Passover start on Thursday. */\ntypes['1721'] = types['170'];\n\nconst sedraCache = new QuickLRU<string, Sedra>({maxSize: 400});\n\n/**\n * Convenience function to create an instance of `Sedra` or reuse a previously\n * created and cached instance.\n * @param hyear\n * @param il\n */\nexport function getSedra(hyear: number, il: boolean): Sedra {\n  const cacheKey = `${hyear}-${il ? 1 : 0}`;\n  let sedra = sedraCache.get(cacheKey);\n  if (!sedra) {\n    sedra = new Sedra(hyear, il);\n    sedraCache.set(cacheKey, sedra);\n  }\n  return sedra;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}