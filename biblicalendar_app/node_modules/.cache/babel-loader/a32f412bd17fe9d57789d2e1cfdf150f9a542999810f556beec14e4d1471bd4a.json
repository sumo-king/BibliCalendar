{"ast":null,"code":"/*! @hebcal/hdate v0.13.5, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport { pad4, pad2 } from './pad.js';\nconst _formatters = new Map();\n/**\n * @private\n */\nfunction getFormatter(tzid) {\n  const fmt = _formatters.get(tzid);\n  if (fmt) return fmt;\n  const f = new Intl.DateTimeFormat('en-US', {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n    timeZone: tzid\n  });\n  _formatters.set(tzid, f);\n  return f;\n}\nconst dateFormatRegex = /^(\\d+).(\\d+).(\\d+),?\\s+(\\d+).(\\d+).(\\d+)/;\n/**\n * Returns a string similar to `Date.toISOString()` but in the\n * timezone `tzid`. Contrary to the typical meaning of `Z` at the end\n * of the string, this is not actually a UTC date.\n */\nfunction getPseudoISO(tzid, date) {\n  const str = getFormatter(tzid).format(date);\n  const m = dateFormatRegex.exec(str);\n  if (m === null) {\n    throw new Error(`Unable to parse formatted string: ${str}`);\n  }\n  let hour = m[4];\n  if (hour === '24') {\n    hour = '00';\n  }\n  m[3] = pad4(parseInt(m[3], 10));\n  return `${m[3]}-${m[1]}-${m[2]}T${hour}:${m[5]}:${m[6]}Z`;\n}\n/**\n * Returns number of minutes `tzid` is offset from UTC on date `date`.\n */\nfunction getTimezoneOffset(tzid, date) {\n  const utcStr = getPseudoISO('UTC', date);\n  const localStr = getPseudoISO(tzid, date);\n  const diffMs = new Date(utcStr).getTime() - new Date(localStr).getTime();\n  return Math.ceil(diffMs / 1000 / 60);\n}\n/**\n * Returns YYYY-MM-DD in the local timezone\n */\nfunction isoDateString(dt) {\n  return pad4(dt.getFullYear()) + '-' + pad2(dt.getMonth() + 1) + '-' + pad2(dt.getDate());\n}\nexport { getPseudoISO, getTimezoneOffset, isoDateString };","map":{"version":3,"names":["_formatters","Map","getFormatter","tzid","fmt","get","f","Intl","DateTimeFormat","year","month","day","hour","minute","second","hour12","timeZone","set","dateFormatRegex","getPseudoISO","date","str","format","m","exec","Error","pad4","parseInt","getTimezoneOffset","utcStr","localStr","diffMs","Date","getTime","Math","ceil","isoDateString","dt","getFullYear","pad2","getMonth","getDate"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/dateFormat.ts"],"sourcesContent":["import {pad2, pad4} from './pad';\n\nconst _formatters = new Map();\n\n/**\n * @private\n */\nfunction getFormatter(tzid: string): Intl.DateTimeFormat {\n  const fmt = _formatters.get(tzid);\n  if (fmt) return fmt;\n  const f = new Intl.DateTimeFormat('en-US', {\n    year: 'numeric',\n    month: '2-digit',\n    day: '2-digit',\n    hour: '2-digit',\n    minute: '2-digit',\n    second: '2-digit',\n    hour12: false,\n    timeZone: tzid,\n  });\n  _formatters.set(tzid, f);\n  return f;\n}\n\nconst dateFormatRegex = /^(\\d+).(\\d+).(\\d+),?\\s+(\\d+).(\\d+).(\\d+)/;\n\n/**\n * Returns a string similar to `Date.toISOString()` but in the\n * timezone `tzid`. Contrary to the typical meaning of `Z` at the end\n * of the string, this is not actually a UTC date.\n */\nexport function getPseudoISO(tzid: string, date: Date): string {\n  const str = getFormatter(tzid).format(date);\n  const m = dateFormatRegex.exec(str);\n  if (m === null) {\n    throw new Error(`Unable to parse formatted string: ${str}`);\n  }\n  let hour = m[4];\n  if (hour === '24') {\n    hour = '00';\n  }\n  m[3] = pad4(parseInt(m[3], 10));\n  return `${m[3]}-${m[1]}-${m[2]}T${hour}:${m[5]}:${m[6]}Z`;\n}\n\n/**\n * Returns number of minutes `tzid` is offset from UTC on date `date`.\n */\nexport function getTimezoneOffset(tzid: string, date: Date): number {\n  const utcStr = getPseudoISO('UTC', date);\n  const localStr = getPseudoISO(tzid, date);\n  const diffMs = new Date(utcStr).getTime() - new Date(localStr).getTime();\n  return Math.ceil(diffMs / 1000 / 60);\n}\n\n/**\n * Returns YYYY-MM-DD in the local timezone\n */\nexport function isoDateString(dt: Date): string {\n  return (\n    pad4(dt.getFullYear()) +\n    '-' +\n    pad2(dt.getMonth() + 1) +\n    '-' +\n    pad2(dt.getDate())\n  );\n}\n"],"mappings":";;AAEA,MAAMA,WAAW,GAAG,IAAIC,GAAG,EAAE;AAE7B;;AAEG;AACH,SAASC,YAAYA,CAACC,IAAY;EAChC,MAAMC,GAAG,GAAGJ,WAAW,CAACK,GAAG,CAACF,IAAI,CAAC;EACjC,IAAIC,GAAG,EAAE,OAAOA,GAAG;EACnB,MAAME,CAAC,GAAG,IAAIC,IAAI,CAACC,cAAc,CAAC,OAAO,EAAE;IACzCC,IAAI,EAAE,SAAS;IACfC,KAAK,EAAE,SAAS;IAChBC,GAAG,EAAE,SAAS;IACdC,IAAI,EAAE,SAAS;IACfC,MAAM,EAAE,SAAS;IACjBC,MAAM,EAAE,SAAS;IACjBC,MAAM,EAAE,KAAK;IACbC,QAAQ,EAAEb;EACX,EAAC;EACFH,WAAW,CAACiB,GAAG,CAACd,IAAI,EAAEG,CAAC,CAAC;EACxB,OAAOA,CAAC;AACV;AAEA,MAAMY,eAAe,GAAG,0CAA0C;AAElE;;;;AAIG;AACa,SAAAC,YAAYA,CAAChB,IAAY,EAAEiB,IAAU;EACnD,MAAMC,GAAG,GAAGnB,YAAY,CAACC,IAAI,CAAC,CAACmB,MAAM,CAACF,IAAI,CAAC;EAC3C,MAAMG,CAAC,GAAGL,eAAe,CAACM,IAAI,CAACH,GAAG,CAAC;EACnC,IAAIE,CAAC,KAAK,IAAI,EAAE;IACd,MAAM,IAAIE,KAAK,CAAC,qCAAqCJ,GAAG,EAAE,CAAC;;EAE7D,IAAIT,IAAI,GAAGW,CAAC,CAAC,CAAC,CAAC;EACf,IAAIX,IAAI,KAAK,IAAI,EAAE;IACjBA,IAAI,GAAG,IAAI;;EAEbW,CAAC,CAAC,CAAC,CAAC,GAAGG,IAAI,CAACC,QAAQ,CAACJ,CAAC,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;EAC/B,OAAO,GAAGA,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAIX,IAAI,IAAIW,CAAC,CAAC,CAAC,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,GAAG;AAC3D;AAEA;;AAEG;AACa,SAAAK,iBAAiBA,CAACzB,IAAY,EAAEiB,IAAU;EACxD,MAAMS,MAAM,GAAGV,YAAY,CAAC,KAAK,EAAEC,IAAI,CAAC;EACxC,MAAMU,QAAQ,GAAGX,YAAY,CAAChB,IAAI,EAAEiB,IAAI,CAAC;EACzC,MAAMW,MAAM,GAAG,IAAIC,IAAI,CAACH,MAAM,CAAC,CAACI,OAAO,EAAE,GAAG,IAAID,IAAI,CAACF,QAAQ,CAAC,CAACG,OAAO,EAAE;EACxE,OAAOC,IAAI,CAACC,IAAI,CAACJ,MAAM,GAAG,IAAI,GAAG,EAAE,CAAC;AACtC;AAEA;;AAEG;AACG,SAAUK,aAAaA,CAACC,EAAQ;EACpC,OACEX,IAAI,CAACW,EAAE,CAACC,WAAW,EAAE,CAAC,GACtB,GAAG,GACHC,IAAI,CAACF,EAAE,CAACG,QAAQ,EAAE,GAAG,CAAC,CAAC,GACvB,GAAG,GACHD,IAAI,CAACF,EAAE,CAACI,OAAO,EAAE,CAAC;AAEtB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}