{"ast":null,"code":"/*! @hebcal/core v5.9.0, distributed under GPLv2 https://www.gnu.org/licenses/gpl-2.0.txt */\nimport { months, HDate, greg2abs, daysInGregMonth, isDate } from '@hebcal/hdate';\nconst TISHREI = months.TISHREI;\n/**\n * Gets the R.D. days for a number, Date, or HDate\n * @private\n */\nfunction getAbs(d) {\n  if (typeof d === 'number') return d;\n  if (isDate(d)) return greg2abs(d);\n  if (HDate.isHDate(d)) return d.abs();\n  throw new TypeError(`Invalid date type: ${d}`);\n}\nfunction getYear(options) {\n  if (typeof options.year !== 'undefined') {\n    return Number(options.year);\n  }\n  return options.isHebrewYear ? new HDate().getFullYear() : new Date().getFullYear();\n}\n/**\n * Parse options object to determine start & end days\n * @private\n */\nfunction getStartAndEnd(options) {\n  if (options.start && !options.end || options.end && !options.start) {\n    throw new TypeError('Both options.start and options.end are required');\n  } else if (options.start && options.end) {\n    return [getAbs(options.start), getAbs(options.end)];\n  }\n  const isHebrewYear = Boolean(options.isHebrewYear);\n  const theYear = getYear(options);\n  if (isNaN(theYear)) {\n    throw new RangeError(`Invalid year ${options.year}`);\n  } else if (isHebrewYear && theYear < 1) {\n    throw new RangeError(`Invalid Hebrew year ${theYear}`);\n  }\n  const theMonth = getMonth(options);\n  const numYears = Number(options.numYears) || 1;\n  if (isHebrewYear) {\n    return startEndHebrew(theMonth, theYear, numYears);\n  } else {\n    return startEndGregorian(theMonth, theYear, numYears);\n  }\n}\nfunction getMonth(options) {\n  if (options.month) {\n    if (options.isHebrewYear) {\n      return HDate.monthNum(options.month);\n    } else if (typeof options.month === 'number') {\n      return options.month;\n    }\n  }\n  return NaN;\n}\nfunction startEndGregorian(theMonth, theYear, numYears) {\n  const gregMonth = theMonth ? theMonth - 1 : 0;\n  const startGreg = new Date(theYear, gregMonth, 1);\n  if (theYear < 100) {\n    startGreg.setFullYear(theYear);\n  }\n  const startAbs = greg2abs(startGreg);\n  let endAbs;\n  if (theMonth) {\n    endAbs = startAbs + daysInGregMonth(theMonth, theYear) - 1;\n  } else {\n    const endYear = theYear + numYears;\n    const endGreg = new Date(endYear, 0, 1);\n    if (endYear < 100) {\n      endGreg.setFullYear(endYear);\n    }\n    endAbs = greg2abs(endGreg) - 1;\n  }\n  return [startAbs, endAbs];\n}\nfunction startEndHebrew(theMonth, theYear, numYears) {\n  const startDate = new HDate(1, theMonth || TISHREI, theYear);\n  let startAbs = startDate.abs();\n  const endAbs = theMonth ? startAbs + startDate.daysInMonth() : new HDate(1, TISHREI, theYear + numYears).abs() - 1;\n  // for full Hebrew year, start on Erev Rosh Hashana which\n  // is technically in the previous Hebrew year\n  // (but conveniently lets us get candle-lighting time for Erev)\n  if (!theMonth && theYear > 1) {\n    startAbs--;\n  }\n  return [startAbs, endAbs];\n}\nexport { getStartAndEnd };","map":{"version":3,"names":["TISHREI","months","getAbs","d","isDate","greg2abs","HDate","isHDate","abs","TypeError","getYear","options","year","Number","isHebrewYear","getFullYear","Date","getStartAndEnd","start","end","Boolean","theYear","isNaN","RangeError","theMonth","getMonth","numYears","startEndHebrew","startEndGregorian","month","monthNum","NaN","gregMonth","startGreg","setFullYear","startAbs","endAbs","daysInGregMonth","endYear","endGreg","startDate","daysInMonth"],"sources":["/Users/shelton/Desktop/Personal Projects/BibliCalendar/biblicalendar_app/node_modules/@hebcal/src/getStartAndEnd.ts"],"sourcesContent":["import {greg2abs, isDate, daysInGregMonth, HDate, months} from '@hebcal/hdate';\nimport {CalOptions} from './CalOptions';\n\nconst TISHREI = months.TISHREI;\n\n/**\n * Gets the R.D. days for a number, Date, or HDate\n * @private\n */\nfunction getAbs(d: Date | HDate | number): number {\n  if (typeof d === 'number') return d;\n  if (isDate(d)) return greg2abs(d as Date);\n  if (HDate.isHDate(d)) return (d as HDate).abs();\n  throw new TypeError(`Invalid date type: ${d}`);\n}\n\nfunction getYear(options: CalOptions): number {\n  if (typeof options.year !== 'undefined') {\n    return Number(options.year);\n  }\n  return options.isHebrewYear\n    ? new HDate().getFullYear()\n    : new Date().getFullYear();\n}\n\n/**\n * Parse options object to determine start & end days\n * @private\n */\nexport function getStartAndEnd(options: CalOptions): number[] {\n  if ((options.start && !options.end) || (options.end && !options.start)) {\n    throw new TypeError('Both options.start and options.end are required');\n  } else if (options.start && options.end) {\n    return [getAbs(options.start), getAbs(options.end)];\n  }\n  const isHebrewYear = Boolean(options.isHebrewYear);\n  const theYear = getYear(options);\n  if (isNaN(theYear)) {\n    throw new RangeError(`Invalid year ${options.year}`);\n  } else if (isHebrewYear && theYear < 1) {\n    throw new RangeError(`Invalid Hebrew year ${theYear}`);\n  }\n  const theMonth = getMonth(options);\n  const numYears = Number(options.numYears) || 1;\n  if (isHebrewYear) {\n    return startEndHebrew(theMonth, theYear, numYears);\n  } else {\n    return startEndGregorian(theMonth, theYear, numYears);\n  }\n}\n\nfunction getMonth(options: CalOptions): number {\n  if (options.month) {\n    if (options.isHebrewYear) {\n      return HDate.monthNum(options.month);\n    } else if (typeof options.month === 'number') {\n      return options.month;\n    }\n  }\n  return NaN;\n}\n\nfunction startEndGregorian(\n  theMonth: number,\n  theYear: number,\n  numYears: number\n): number[] {\n  const gregMonth = theMonth ? theMonth - 1 : 0;\n  const startGreg = new Date(theYear, gregMonth, 1);\n  if (theYear < 100) {\n    startGreg.setFullYear(theYear);\n  }\n  const startAbs = greg2abs(startGreg);\n  let endAbs;\n  if (theMonth) {\n    endAbs = startAbs + daysInGregMonth(theMonth, theYear) - 1;\n  } else {\n    const endYear = theYear + numYears;\n    const endGreg = new Date(endYear, 0, 1);\n    if (endYear < 100) {\n      endGreg.setFullYear(endYear);\n    }\n    endAbs = greg2abs(endGreg) - 1;\n  }\n  return [startAbs, endAbs];\n}\n\nfunction startEndHebrew(\n  theMonth: number,\n  theYear: number,\n  numYears: number\n): number[] {\n  const startDate = new HDate(1, theMonth || TISHREI, theYear);\n  let startAbs = startDate.abs();\n  const endAbs = theMonth\n    ? startAbs + startDate.daysInMonth()\n    : new HDate(1, TISHREI, theYear + numYears).abs() - 1;\n  // for full Hebrew year, start on Erev Rosh Hashana which\n  // is technically in the previous Hebrew year\n  // (but conveniently lets us get candle-lighting time for Erev)\n  if (!theMonth && theYear > 1) {\n    startAbs--;\n  }\n  return [startAbs, endAbs];\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}